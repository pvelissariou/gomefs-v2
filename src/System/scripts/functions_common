# Author:  Panagiotis Velissariou <pvelissariou@fsu.edu>
#                                 <velissariou.1@osu.edu>
# Version: 1.8
#
# Version - 1.8 Tue Sep 22 2015
# Version - 1.7 Thu Jul 30 2015
# Version - 1.6 Wed Aug 20 2014
# Version - 1.5 Wed Jul 16 2014
# Version - 1.4 Mon Mar  3 2014
# Version - 1.3 Fri Jul 26 2013
# Version - 1.2 Sun Jul 21 2013
# Version - 1.1 Wed Jul 25 2012
# Version - 1.0 Thu Apr 15 2004

set +u

REF_DATE="1901/01/01 00:00:00"

SUPPORTED_OCEAN_MODELS="ROMS HYCOM"


#------------------------------------------------------------
# UTILITY FUNCTIONS
#------------------------------------------------------------


############################################################
##### COLOR FUNCTIONS
############################################################
# Ascii color definitions
#  0    reset all attributes to their defaults
#  1    set bold
#  2    set half-bright (simulated with color on a color display)
#  4    set underscore (simulated with color on a color display)
#  5    set blink
#  7    set reverse video
# 22    set normal intensity
# 24    underline off
# 25    blink off
# 27    reverse video off
# 30    set black foreground
# 31    set red foreground
# 32    set green foreground
# 33    set brown foreground
# 34    set blue foreground
# 35    set magenta foreground
# 36    set cyan foreground
# 37    set white foreground
# 38    set underscore on, set default foreground color
# 39    set underscore off, set default foreground color
# 40    set black background
# 41    set red background
# 42    set green background
# 43    set brown background
# 44    set blue background
# 45    set magenta background
# 46    set cyan background
# 47    set white background
# 49    set default background color

# -------------------------------------------------------
# clrtxt()
# Usage:      clrtxt [options] text
# Parameters: text (string)
# Returns:    0 upon success and 1 upon failure
# Echoes:     the resulting text
#
# Possible options are:
# -b make bold text (no option argument)
# -f make flashing text (no option argument)
# -u make underlined text (no option argument)
# -c make colored text, color values can be one of:
#    black, red, green, yellow, blue, magenta, cyan, white
# -d use a delimeter before/after the text, possible values are:
#    1 = "[,]", 2 = "{,}" and 3 = "(,)"
# -o offset the text by a number of columns (int)

# Echoes a colorized text on the terminal
# -------------------------------------------------------
clrtxt()
{
  local -i retval=0 offset=0
  local get_opts= my_arg= echoval=
  local dftxt= bdtxt= ultxt= fltxt= black=  white=
  local red= green= yellow= blue= magenta= cyan=
  local txt_b= txt_f= txt_u= txt_c=
  local txt_d1= txt_d2= txt_o=
# Use these to reset the options since the shell does not
# do that automatically
  local opt_id=${OPTIND} opt_arg="${OPTARG}"

  [ $# -eq 0 ] && return 1
  
  if [ "${COLORSET:-unset}" != "unset" ]; then
  # Text colors
    black=$( echo -en "\\033[0;30m" )
    red=$( echo -en "\\033[0;31m" )
    green=$( echo -en "\\033[0;32m" )
    yellow=$( echo -en "\\033[0;33m" )
    blue=$( echo -en "\\033[0;34m" )
    magenta=$( echo -en "\\033[0;35m" )
    cyan=$( echo -en "\\033[0;36m" )
    white=$( echo -en "\\033[0;37m" )
  # Text effects
    dftxt=$( echo -en "\\033[0m" )
    bdtxt=$( echo -en "\\033[1m" )
    ultxt=$( echo -en "\\033[4m" )
    fltxt=$( echo -en "\\033[5m" )
  fi

  while getopts ":bfuc:o:d:" get_opts
  do
    case ${get_opts} in
      b) txt_b="${bdtxt}" ;;
      f) txt_f="${fltxt}" ;;
      u) txt_u="${ultxt}" ;;
      c) case "${OPTARG}" in
             black) txt_c="${black}" ;;
               red) txt_c="${red}" ;;
             green) txt_c="${green}" ;;
            yellow) txt_c="${yellow}" ;;
              blue) txt_c="${blue}" ;;
           magenta) txt_c="${magenta}" ;;
              cyan) txt_c="${cyan}" ;;
             white) txt_c="${white}" ;;
                 *) ;;
         esac ;;
      o) offset=${OPTARG}
         [ ${OPTARG} -ne 0 ] && \
           txt_o="$( echo -en "\\033[${offset}C" )" ;;
      d) case "${OPTARG}" in
           1) txt_d1='['
              txt_d2=']' ;;
           2) txt_d1='{'
              txt_d2='}' ;;
           3) txt_d1='('
              txt_d2=')' ;;
           *) ;;
         esac ;;
      *) ;; # DEFAULT
    esac
  done

# Get the first argument after the options
  shift $(( ${OPTIND} - 1 ))
  my_arg="${1}"

# Reset the option variables since the shell doesn't do it
  OPTIND=${opt_id}
  OPTARG="${opt_arg}"

  [ "X${my_arg}" = "X" ] && return 1

# Work on the options
  if [ "X${txt_b}" != "X" ]; then
    [ "X${txt_d1}" != "X" ] && \
      txt_d1="${dftxt}${txt_b}${txt_d1}${dftxt}"
    [ "X${txt_d2}" != "X" ] && \
      txt_d2="${dftxt}${txt_b}${txt_d2}${dftxt}"
  fi

# Build the output text
  echoval="${txt_o}${txt_d1}${txt_c}"
  echoval="${echoval}${txt_b}${txt_u}${txt_f}"
  echoval="${echoval}${my_arg}${dftxt}${txt_d2}"

  echo -en "${echoval}"

  return 0
}

# -------------------------------------------------------
# clrset()
# Usage:      clrset [color]
# Parameters: color (string)
#             color=black,red,green,yellow,blue,magenta,cyan,white
#             If no argument is supplied resets to the default
# Returns:    0 upon success and 1 upon failure
# Echoes:     If the variable COLORSET is set then echoes
#             the ascii sequence of the resulting color. If it
#             is called without arguments and the variable COLORSET
#             is set it echoes the "default text" ascii sequence
#
# -------------------------------------------------------
clrset()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  if [ $# -gt 0 ]; then
    case ${1} in
        black) echo -en "\\033[0;30m" ;;
          red) echo -en "\\033[0;31m" ;;
        green) echo -en "\\033[0;32m" ;;
       yellow) echo -en "\\033[0;33m" ;;
         blue) echo -en "\\033[0;34m" ;;
      magenta) echo -en "\\033[0;35m" ;;
         cyan) echo -en "\\033[0;36m" ;;
        white) echo -en "\\033[0;37m" ;;
            *) ;; # DEFAULT
    esac
  else
    # Reset the color
    echo -en "\\033[0m"
  fi
  return ${retval}
}

# -------------------------------------------------------
# bdon(), bdoff(), bdtxt()
# Usage:      bdon, bdoff, bdtxt text
# Parameters: bdon, bdoff : NONE, bdtxt text (string)
# Returns:    0
# Example:    `bdon`Some Text`bdoff`
#             bdon Some Text bdoff
# Echoes:     The function "bdon" echoes the "bold text"
#             ascii sequence and the function "bdoff"
#             echoes the "normal text" ascii sequence
#             (that is, bold text on and off)
# -------------------------------------------------------
bdon()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  echo -en "\\033[1m"
  return ${retval}
}
bdoff()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  echo -en "\\033[22m"
  return ${retval}
}
bdtxt()
{
  local -i retval=0
  local echoval="${1}"

  [ "${COLORSET:-unset}" = "unset" ] && \
    { echo -en ${echoval}; return ${retval}; }

  [ "X${echoval}" = "X" ] && \
    { echo -en ${echoval}; return ${retval}; }

  echo -en "\\033[1m${echoval}\\033[22m"

  return ${retval}
}

# -------------------------------------------------------
# ulon(), uloff(), ultxt()
# Usage:      ulon, uloff, ultxt text
# Parameters: ulon, uloff : NONE, ultxt text (string)
# Returns:    0
# Example:    `ulon`Some Text`uloff`
#             ulon Some Text uloff
# Echoes:     The function "ulon" echoes the "underline text"
#             ascii sequence and the function "uloff"
#             echoes the "normal text" ascii sequence
#             (that is, underline text on and off)
# -------------------------------------------------------
ulon()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  echo -en "\\033[4m"
  return ${retval}
}
uloff()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  echo -en "\\033[24m"
  return ${retval}
}
ultxt()
{
  local -i retval=0
  local echoval="${1}"

  [ "${COLORSET:-unset}" = "unset" ] && \
    { echo -en ${echoval}; return ${retval}; }

  [ "X${echoval}" = "X" ] && \
    { echo -en ${echoval}; return ${retval}; }

  echo -en "\\033[4m${echoval}\\033[24m"

  return ${retval}
}

# -------------------------------------------------------
# flon(), floff(), fltxt()
# Usage:      flon, floff, fltxt text
# Parameters: flon, floff : NONE, fltxt text (string)
# Returns:    0
# Example:    `flon`Some Text`floff`
#             flon Some Text floff
# Echoes:     The function "flon" echoes the "flashing text"
#             ascii sequence and the function "floff"
#             echoes the "normal text" ascii sequence
#             (that is, flashing text on and off)
# -------------------------------------------------------
flon()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  echo -en "\\033[5m"
  return ${retval}
}
floff()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  echo -en "\\033[25m"
  return ${retval}
}
fltxt()
{
  local -i retval=0
  local echoval="${1}"

  [ "${COLORSET:-unset}" = "unset" ] && \
    { echo -en ${echoval}; return ${retval}; }

  [ "X${echoval}" = "X" ] && \
    { echo -en ${echoval}; return ${retval}; }

  echo -en "\\033[5m${echoval}\\033[25m"

  return ${retval}
}

# -------------------------------------------------------
# rvon(), rvoff(), rvtxt()
# Usage:      rvon, rvoff, rvtxt text
# Parameters: rvon, rvoff : NONE, rvtxt text (string)
# Returns:    0
# Example:    `rvon`Some Text`rvoff`
#             rvon Some Text rvoff
# Echoes:     The function "rvon" echoes the "reverse video"
#             ascii sequence and the function "rvoff"
#             echoes the "normal video" ascii sequence
#             (that is, reverse video on and off)
# -------------------------------------------------------
rvon()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  echo -en "\\033[7m"
  return ${retval}
}

rvoff()
{
  local -i retval=0

  [ "${COLORSET:-unset}" = "unset" ] && return ${retval}
  echo -en "\\033[27m"
  return ${retval}
}

rvtxt()
{
  local -i retval=0
  local echoval="${1}"

  [ "${COLORSET:-unset}" = "unset" ] && \
    { echo -en ${echoval}; return ${retval}; }

  [ "X${echoval}" = "X" ] && \
    { echo -en ${echoval}; return ${retval}; }

  echo -en "\\033[7m${echoval}\\033[27m"

  return ${retval}
}

esucc()
{
  local -i retval=0

  clrtxt -c green -d 1 "OK"
  return ${retval}
}

efail()
{
  local -i retval=0

  clrtxt -c red -d 1 "FAILED"
  return ${retval}
}

epass()
{
  local -i retval=0

  clrtxt -c yellow -d 1 "PASSED"
  return ${retval}
}

ewarn()
{
  local -i retval=0

  clrtxt -c yellow -d 1 "WARNING"
  return ${retval}
}

eerr()
{
  local -i retval=0

  clrtxt -c red -d 1 "ERROR"
  return ${retval}
}

efunc()
{
  local -i retval=0

  [ $# -eq 0 ] && { echo -en ""; return ${retval}; }

  clrtxt -c magenta "${1}"
  return ${retval}
}

escr()
{
  local -i retval=0

  [ $# -eq 0 ] && { echo -en ""; return ${retval}; }

  clrtxt -c blue "${1}"
  return ${retval}
}

eargs()
{
  local -i retval=0

  [ $# -eq 0 ] && { echo -en ""; return ${retval}; }

  clrtxt -c green "${1}"
  return ${retval}
}

forceExit()
{
  local -i status=1

  echo " `clrset red`### ERROR`clrset`: `escr ${scrNAME}` (`efunc ${FUNCNAME}`)"
  [ "X${1}" != "X" ] && echo "       ${1}"
  echo "     `clrset red`Exiting now ...`clrset`"

  exit ${status}
}

onError()
{
  local -i status=$?
  
  if [ ${status} -ne 0 ]; then
    echo " `clrset red`### ERROR`clrset`: `escr ${scrNAME}` (`efunc ${FUNCNAME}`)"
    [ "X${1}" != "X" ] && echo "       ${1}"
    echo "     `clrset red`Exiting now ...`clrset`"
    exit ${status}
  fi

  return ${status}
}

oftxt ()
{
  echo -en "\\033[${1}C"
}

nrmtxt()
{
  echo -en "${1}"
}
magtxt()
{
  echo -en `clrset magenta`"${1}"`clrset`
}
redtxt()
{
  echo -en `clrset red`"${1}"`clrset`
}
grntxt()
{
  echo -en `clrset green`"${1}"`clrset`
}

blutxt()
{
  echo -en `clrset blue`"${1}"`clrset`
}

yeltxt()
{
  echo -en `clrset yellow`"${1}"`clrset`
}

cyatxt()
{
  echo -en `clrset cyan`"${1}"`clrset`
}

titxt()
{
  clrtxt -o 1 -c green "********************  ${1}  ********************"
  echo
}

sctxt()
{
  clrtxt -o 12 -c blue -b -u "${1}"
  echo
}

optxt()
{
  oftxt 1
  magtxt "${1}"
  oftxt 3
}

envvartxt()
{
  local txt0= txt1= txt2=
  
  txt0="$( clrtxt -c magenta "Associated EnvVar:" )"
  [ -n "${1:+1}" ] && txt1="$( clrtxt -b -c blue "${1}" )"
  [ -n "${2:+1}" ] && txt2="$( clrtxt -b -c red "${2}" )"
  
  echo -en "${txt0}${txt1:+ ${txt1}}${txt2:+ ${txt2}}"
}
############################################################


############################################################
##### PARSE OPTIONS FUNCTIONS
############################################################
# -------------------------------------------------------
# ParseArgs()
# Usage:      ParseArgs args
# Parameters: args = the script/function options
# Returns:    0
# Echoes:     NONE
#
# Gets the supplied options to the script/function.
# -------------------------------------------------------
ParseArgs()
{
  local nm_func=$( basename ${BASH_SOURCE[${#BASH_SOURCE[@]}-1]} )

  local opt_all opt_opt opt_arg

  local ans0 ans ival intN
  local all_evars


  all_evars="CASEID BEG_DATE END_DATE DATE DATE_FMT
             CAST_CYCLE CAST_INIT_DAYS CAST_LENGTH ATM_DATA_HOURS
             ROOT_DIR DATA_DIR DATA_INTERVAL INP_DIR OUT_DIR BATH_DIR
             BDRY_DIR FRC_DIR INI_DIR LOGS_DIR WGHT_DIR IDL_DIR
             MATLAB_DIR PLOTS_DIR WEB_DIR WPS_DIR GEOG_DIR
             DOMS INI_FILES BDRY_FILES HOSTFILE CONF_FILE MODEL_INP
             FORCE_INI MODFILES USER_CPUS FILE_PFX FILE_SFX FILE_TYPE
             VTABLE_SFX LIST_DIR USE_GPAR GPAR_JOBS GPAR_SLF USE_SHMEM
             REMOVE_DIR CLEANUP PRINT_ENV"

  for ival in ${all_evars}; do unset __${ival}; done


  # -----
  # Process the function options
  opt_all=( c start end date dfmt
            cast_cycle cast_ini cast_len atm_int
            rootd datd dat_int inpd outd bathd bdryd frcd inid
            logd wghtd idld matd plotd webd wpsd geogd
            doms ini_files bdry_files host conf inp ini
            m mods n nprocs
            fpfx fsfx ftype vsfx dirs
            par pjobs pslf shm
            rmdir clean p print h help )
  opt_all=":$( echo "${opt_all[@]/#/-} ${opt_all[@]/#/--}" | sed 's/ /:/g' ):"

  __OPTION_LIST=
  while test $# -gt 0; do
    case "${1}" in
      -[^-]*=* | --[^-]*=* )
        opt_opt="$( toLOWER "$( echo "${1}" | sed 's/=.*//' )" )"
        opt_arg="$( strTrim "$( echo "${1}" | sed 's/.*=//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      -[^-]* | --[^-]* )
        opt_opt="$( toLOWER "${1}" )"
        opt_arg="$( strTrim "$( echo "${2}" | sed 's/=.*//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      *)
        opt_opt= 
        opt_arg=
        ;;
    esac

    case "${opt_opt}" in
      -c | --c )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __CASEID="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' )"
          fi
        ;;
      -start | --start )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __BEG_DATE="$( strTrim "${opt_arg}" 2 )"
          fi
        ;;
      -end | --end )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __END_DATE="$( strTrim "${opt_arg}" 2 )"
          fi
        ;;
      -date | --date )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __DATE="$( strTrim "${opt_arg}" 2 )"
          fi
        ;;
      -dfmt | --dfmt )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __DATE_FMT="$( strTrim "${opt_arg}" 2 )"
          fi
        ;;
      -cast_cycle | --cast_cycle )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __CAST_CYCLE="$( getPosInteger "${opt_arg}" )"
            [ $? -ne 0 ] && __CAST_CYCLE=0
          fi
        ;;
      -cast_ini | --cast_ini )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __CAST_INIT_DAYS="$( getPosInteger "${opt_arg}" )"
            [ $? -ne 0 ] && __CAST_INIT_DAYS=0
          fi
        ;;
      -cast_len | --cast_len )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __CAST_LENGTH="$( getPosInteger "${opt_arg}" )"
            [ $? -ne 0 ] && __CAST_LENGTH=1
          fi
        ;;
      -atm_int | --atm_int )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __ATM_DATA_HOURS="$( getPosInteger "${opt_arg}" )"
            [ $? -ne 0 ] && __ATM_DATA_HOURS=6
          fi
        ;;
      -rootd | --rootd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __ROOT_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -datd | --datd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __DATA_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -dat_int | --dat_int )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __DATA_INTERVAL="$( getPosInteger "${opt_arg}" )"
            [ $? -ne 0 ] && __DATA_INTERVAL=6
          fi
        ;;
      -inpd | --inpd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __INP_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -outd | --outd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __OUT_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -bathd | --bathd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __BATH_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -bdryd | --bdryd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __BDRY_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -frcd | --frcd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __FRC_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -inid | --inid )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __INI_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -logd | --logd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __LOGS_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -wghtd | --wghtd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __WGHT_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -idld | --idld )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __IDL_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -matd | --matd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __MATLAB_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -plotd | --plotd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __PLOTS_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -webd | --webd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __WEB_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -wpsd | --wpsd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __WPS_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -geogd | --geogd )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __GEOG_DIR="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -doms | --doms )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __DOMS=( ${opt_arg} )
            for ((ival = 0; ival < ${#__DOMS[@]}; ival++))
            do
              intN=$( getPosInteger "${__DOMS[${ival}]}" )
              [ $? -ne 0 ] && intN=0
              case "${ival}" in
                0) __DOM_OCN=${intN} ;;
                1) __DOM_WRF=${intN}  ;;
                2) __DOM_SWAN=${intN} ;;
                3) __DOM_SED=${intN}  ;;
                *) ;;
              esac
            done
            __DOMS="${__DOMS[@]}"
          fi
        ;;
      -ini_files | --ini_files )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __INI_FILES=1
          if [ "X${opt_arg}" != "X" ]; then
            [ "$( getYesNo "${opt_arg}" )" = "no" ] && __INI_FILES=0
          fi
        ;;
      -bdry_files | --bdry_files )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __BDRY_FILES=1
          if [ "X${opt_arg}" != "X" ]; then
            [ "$( getYesNo "${opt_arg}" )" = "no" ] && __BDRY_FILES=0
          fi
        ;;
      -host | --host )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __HOSTFILE="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -conf | --conf )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __CONF_FILE="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -inp | --inp )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __MODEL_INP="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' | sed 's#/*$##' )"
          fi
        ;;
      -ini | --ini )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __FORCE_INI=1
          if [ "X${opt_arg}" != "X" ]; then
            [ "$( getYesNo "${opt_arg}" )" = "no" ] && __FORCE_INI=0
          fi
        ;;
      -m | -mods | --m | --mods )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __MODFILES="$( strTrim "${opt_arg}" 2 )"
          fi
        ;;
      -n | -nprocs | --n | --nprocs )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __USER_CPUS=1
          if [ "X${opt_arg}" != "X" ]; then
            __USER_CPUS="$( getPosInteger "${opt_arg}" )"
            [ $? -ne 0 ] && __USER_CPUS=1
          fi
        ;;
      -fpfx | --fpfx )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __FILE_PFX="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' )"
          fi
        ;;
      -fsfx | --fsfx )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __FILE_SFX="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' )"
          fi
        ;;
      -ftype | --ftype )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __FILE_TYPE="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' )"
          fi
        ;;
      -vsfx | --vsfx )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __VTABLE_SFX="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' )"
          fi
        ;;
      -dirs | --dirs )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              __LIST_DIR="$( strTrim "${opt_arg}" 2 )"
          fi
        ;;
      -par | --par )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __USE_GPAR=1
          if [ "X${opt_arg}" != "X" ]; then
            [ "$( getYesNo "${opt_arg}" )" = "no" ] && __USE_GPAR=0
          fi
        ;;
      -pjobs | --pjobs )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __GPAR_JOBS=1
          if [ "X${opt_arg}" != "X" ]; then
            __GPAR_JOBS="$( getPosInteger "${opt_arg}" )"
            [ $? -ne 0 ] && __GPAR_JOBS=1
          fi
        ;;
      -pslf | --pslf )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            __GPAR_SLF="$( echo "${opt_arg}" | sed 's/[[:space:]]//g' )"
          fi
        ;;
      -shm | --shm )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __USE_SHMEM=1
          if [ "X${opt_arg}" != "X" ]; then
            [ "$( getYesNo "${opt_arg}" )" = "no" ] && __USE_SHMEM=0
          fi
        ;;
      -rmdir | --rmdir )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __REMOVE_DIR=1
          if [ "X${opt_arg}" != "X" ]; then
            [ "$( getYesNo "${opt_arg}" )" = "no" ] && __REMOVE_DIR=0
          fi
        ;;
      -clean | --clean )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __CLEANUP=1
          if [ "X${opt_arg}" != "X" ]; then
            [ "$( getYesNo "${opt_arg}" )" = "no" ] && __CLEANUP=0
          fi
        ;;
      -p | -print | --p | --print )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          __PRINT_ENV=1
          if [ "X${opt_arg}" != "X" ]; then
            [ "$( getYesNo "${opt_arg}" )" = "no" ] && __PRINT_ENV=0
          fi
        ;;
      -h | -help | --h | --help )
          Usage ${nm_func}
        ;;
      *) ;; # DEFAULT
    esac
    shift
    opt_opt= 
    opt_arg=
  done
  __OPTION_LIST=

  # Export the values of all __* variables.
  for ival in ${all_evars}
  do
    ans0="$( eval "echo \${$(echo ${ival}):-}" )"
    ans="$( eval "echo \${$(echo __${ival}):-}" )"
    ans=${ans:-${ans0:-}}

    eval "${ival}=\${ans}"
    export ${ival}

    unset __${ival}
  done

  return 0
}

Usage()
{
  local nm="$( basename ${1:-${0}} )"
  
  local old_COLORSET

  old_COLORSET=${COLORSET:-}
  adjustYESNOVar COLORSET

  echo
  redtxt "Usage: \"${nm}\" [{-|--}option1{=|space}[option_value1]] [{-|--}option2{=|space}[option_value2]] ..."
  echo; optxt  "Example:    -doms \"1 2 1 1\",  -doms=\"1 2 1 1\""; nrmtxt "(both set doms for OCN WRF SWAN SED)"
  echo; optxt  "           --doms \"1 2 1 1\", --doms=\"1 2 1 1\""; nrmtxt "(both set doms for OCN WRF SWAN SED)"
  echo
  sleep 1

  echo; titxt "AVAILABLE OPTIONS"; echo
  echo " In addition to passing the configuration parameters/variables using"
  echo "   the available options of this script, the configuration parameters/variables"
  echo "   can also be obtained from the environment if the defaults are not sufficient."
  echo " The environment variables can be set (a) from the command line,"
  echo "   (b) by exporting them to the environment prior of running this script,"
  echo "   (c) by sourcing a configuration environment file."
  echo " For a further explanation of these variables, see the script source code."

  echo; sctxt "General options"
  #---
  optxt "h|help"; echo
  echo "    Show this help screen and then exit."
  #---
  optxt "p|print"; echo
  echo "    Print the environment variable values set and then exit."
  #---
  optxt "c \"caseid\""; envvartxt CASEID "(optional)."; echo
  echo "    Set a name/id for the case being run/compiled."
  echo "    Default: not set."
  #---
  optxt "start \"start_date\""; envvartxt BEG_DATE "(mandatory)."; echo
  echo "    Define the beginning date of the simulation."
  echo "    Format : YYYY/MM/DD [HH:MN:SC] or YYYY-MM-DD [HH:MN:SC]."
  echo "    Default: not set."
  #---
  optxt "end \"end_date\""; envvartxt END_DATE "(mandatory)."; echo
  echo "    Define the end date of the simulation."
  echo "    Format : YYYY/MM/DD [HH:MN:SC] or YYYY-MM-DD [HH:MN:SC]."
  echo "    Default: not set."
  #---
  optxt "date \"date\""; envvartxt DATE "(optional)."; echo
  echo "    Define a general date if required for a part of the simulation."
  echo "    Format : YYYY/MM/DD [HH:MN:SC] or YYYY-MM-DD [HH:MN:SC]."
  echo "    Default: not set."
  #---
  optxt "dfmt \"date_format\""; envvartxt DATE_FMT "(optional)."; echo
  echo "    Define a format to be used for the date string in the filename when searching for files."
  echo "    Format : One or more of: YMDH YMD YM Y MDYH MDY MY DMYH DMY YJH YJ JY"
  echo "    Default: not set."
  #---
  optxt "cast_cycle \"0|6|12|18\""; envvartxt CAST_CYCLE "(optional)."; echo
  echo "    The forecast cycle (a positive integer value)."
  echo "    Possible values are one of: 0 6 12 18."
  echo "    Default: 0."
  #---
  optxt "cast_ini \"ini_days\""; envvartxt CAST_INIT_DAYS "(optional)."; echo
  echo "    Initialization time for the current forecast (a positive integer value)."
  echo "    Days back from the actual forecast date and time (spinup period)."
  echo "    Default: 0."
  #---
  optxt "cast_len \"len_days\""; envvartxt CAST_LENGTH "(optional)."; echo
  echo "    Length of the current forecast (a positive integer value)."
  echo "    Days in the future from the actual forecast date and time (forecast length)."
  echo "    Default: 5."
  #---
  optxt "atm_int \"3 6\""; envvartxt ATM_DATA_HOURS "(optional)."; echo
  echo "    The time interval (hours) for the input atmospheric records (a positive integer value)."
  echo "    Possible values are one of: 3 6."
  echo "    Default: 6."
  #---
  optxt "rootd \"root_dir\""; envvartxt ROOT_DIR "(optional)."; echo
  echo "    The path to the modeling system root directory. All other directories are"
  echo "    set by default relative to this directory."
  echo "    Default: is set internally by the modeling system."
  #---
  optxt "datd \"data_dir\""; envvartxt DATA_DIR "(optional)."; echo
  echo "    The root data directory where all necessary data for this simulation are stored."
  echo "    Default: ROOT_DIR/Data."
  #---
  optxt "dat_int \"0-23\""; envvartxt DATA_INTERVAL "(optional)."; echo
  echo "    The time interval (hours) between data records (a positive integer value)."
  echo "    Possible values are one of: 0 to 23."
  echo "    Default: 6."
  #---
  optxt "inpd \"inp_dir\""; envvartxt INP_DIR "(optional)."; echo
  echo "    A general directory where model input/data files are stored."
  echo "    Default: not set."
  #---
  optxt "outd \"out_dir\""; envvartxt OUT_DIR "(optional)."; echo
  echo "    The root directory where all model output files for this simulation are stored."
  echo "    Default: ROOT_DIR/Output."
  #---
  optxt "bathd \"bath_dir\""; envvartxt BATH_DIR "(optional)."; echo
  echo "    The directory where all model bathymetry/topography files and data are stored."
  echo "    Default: DATA_DIR/bath."
  #---
  optxt "bdryd \"boundary_dir\""; envvartxt BDRY_DIR "(optional)."; echo
  echo "    The directory where all model bathymetry/topography files and data are stored."
  echo "    Default: DATA_DIR/boundary."
  #---
  optxt "frcd \"force_dir\""; envvartxt FRC_DIR "(optional)."; echo
  echo "    The directory where all model forcing files and data are stored."
  echo "    Default: DATA_DIR/forcing."
  #---
  optxt "inid \"ini_dir\""; envvartxt INI_DIR "(optional)."; echo
  echo "    The directory where all model initialization files and data are stored."
  echo "    Default: DATA_DIR/ini."
  #---
  optxt "logd \"logs_dir\""; envvartxt LOGS_DIR "(optional)."; echo
  echo "    The directory where all model log files are stored."
  echo "    Default: ROOT_DIR/Logs."
  #---
  optxt "wghtd \"weights_dir\""; envvartxt WGHT_DIR "(optional)."; echo
  echo "    The directory where all model weight files and data (for grid interpolation) are stored."
  echo "    Default: DATA_DIR/weights."
  #---
  optxt "idld \"idl_dir\""; envvartxt IDL_DIR "(optional)."; echo
  echo "    The directory where all IDL files are stored."
  echo "    Default: ROOT_DIR/idl."
  #---
  optxt "matd \"mat_dir\""; envvartxt MATLAB_DIR "(optional)."; echo
  echo "    The directory where all project MATLAB files are stored."
  echo "    Default: ROOT_DIR/matlab."
  #---
  optxt "plotd \"plots_dir\""; envvartxt PLOTS_DIR "(optional)."; echo
  echo "    The directory where all plots from the current simulation are stored."
  echo "    Default: ROOT_DIR/plots."
  #---
  optxt "webd \"web_dir\""; envvartxt WEB_DIR "(optional)."; echo
  echo "    The directory where all files for displaying model results on the WEB are stored."
  echo "    Default: not set."
  #---
  optxt "wpsd \"wps_dir\""; envvartxt WPS_DIR "(optional)."; echo
  echo "    The directory where all WPS related files, data and utilities are stored."
  echo "    Default: ROOT_DIR/wps."
  #---
  optxt "geogd \"geog_dir\""; envvartxt GEOG_DIR "(mandatory)."; echo
  echo "    The directory under which the geospatial WRF/WPS data are stored."
  echo "    Default: not set."
  #---
  optxt "doms \"model_doms\""; envvartxt DOMS "(optional)."; echo
  echo "    The number of domains (nests) used in each model."
  echo "    A string that contains the number of domains in the following sequence:"
  echo "    model_doms=\"1 1 2 1\", (OCEAN WRF SWAN SED)."
  echo "    Default: 1 for all models."
  #---
  optxt "ini_files \"0|1|yes|no\""; envvartxt INI_FILES "(optional)."; echo
  echo "    A flag to create (or not) model initialization files (an integer)."
  echo "    If ini_files <= 0, then model initialization files are not created."
  echo "    Default: 1."
  #---
  optxt "bdry_files \"0|1|yes|no\""; envvartxt BDRY_FILES "(optional)."; echo
  echo "    A flag to create (or not) model boundary files (an integer)."
  echo "    If bdry_files <= 0, then model boundary files are not created."
  echo "    Default: 1."
  #---
  optxt "host \"host_file\""; envvartxt HOSTFILE "(optional)."; echo
  echo "    The name of the hostfile (machinefile) to be used with MPI runs (if necessary)."
  echo "    Default: not set."
  #---
  optxt "conf \"conf_file\""; envvartxt CONF_FILE "(optional)."; echo
  echo "    The name of the configuration file (if needed) to be used with the current simulation."
  echo "    Default: not set."
  #---
  optxt "inp \"inp_file\""; envvartxt MODEL_INP "(mandatory)."; echo
  echo "    The name of the model input configuration file to be used with the current simulation."
  echo "    Default: not set."
  #---
  optxt "ini \"0|1|yes|no\""; envvartxt FORCE_INI "(optional)."; echo
  echo "    A flag to force (or not) the model to start from initalization files (an integer)."
  echo "    If ini_flag <= 0, then model uses restart files for the current simulation."
  echo "    Default: 0."
  #---
  optxt "m|mods \"modulefiles\""; envvartxt "MODFILES" "(optional)."; echo
  echo "    The names of the modulefiles to load and use for compilation."
  echo "    - controls the environment for the Fortran/C/C++ and MPI compilers."
  echo "    - omit this argument if everything is already in the user's PATH."
  echo "    Default: not set."
  #---
  optxt "n|nprocs \"nprocs\""; envvartxt USER_CPUS "(optional)."; echo
  echo "    The total number of processors to be used for the current simulation (an integer)."
  echo "    Default: 1 (primarily used by the WPS utilities, or mpirun)."
  #---
  optxt "fpfx \"file_pfx\""; envvartxt FILE_PFX "(mandatory)."; echo
  echo "    A prefix (or list of prefixes) to be used when searching for files."
  echo "    It is used during the model run process by various functions and"
  echo "    during pre- and post-processing operations of the modeling system."
  echo "    Default: not set."
  #---
  optxt "fsfx \"file_sfx\""; envvartxt FILE_SFX "(optional)."; echo
  echo "    A suffix (or list of suffixes) to be used when searching for files."
  echo "    It is used during the model run process by various functions and"
  echo "    during pre- and post-processing operations of the modeling system."
  echo "    Default: not set."
  #---
  optxt "ftype \"file_type\""; envvartxt FILE_TYPE "(optional)."; echo
  echo "    The file type (e.g., archv for HYCOM)."
  echo "    It is used during by various functions during pre- and post-processing"
  echo "    operations of the modeling system."
  echo "    Default: not set."
  #---
  optxt "vsfx \"file_sfx\""; envvartxt FILE_SFX "(optional)."; echo
  echo "    The suffix to be used when searching for Vtable files (WPS)."
  echo "    It is used during the model during pre-processing operations"
  echo "    of the modeling system (when creating initial and boundary"
  echo "    conditions for WRF using WPS."
  echo "    Default: not set (values are set internally)."
  #---
  optxt "dirs \"dir_list\""; envvartxt LIST_DIR "(optional)."; echo
  echo "    A list of directories when searching for files."
  echo "    Default: a default list is set internally by the modeling system."
  #---
  optxt "par \"0|1|yes|no\""; envvartxt USE_GPAR "(optional)."; echo
  echo "    Use the GNU parallel for certain modeling tasks."
  echo "    It is used during pre- and post-processing operations by various functions"
  echo "    and tasks of the modeling system."
  echo "    Default: 1."
  #---
  optxt "pjobs \"par_jobs\""; envvartxt GPAR_JOBS "(optional)."; echo
  echo "    The number of GNU parallel jobs (tasks) per node."
  echo "    Default: 1."
  #---
  optxt "pslf \"sshloginfile\""; envvartxt GPAR_SLF "(optional)."; echo
  echo "    The GNU parallel SSH hostfile."
  echo "    Default: .. (\${HOME}/.parallel/sshloginfile)."
  #---
  optxt "shm \"0|1|yes|no\""; envvartxt USE_SHMEM "(optional)."; echo
  echo "    Perform calculations using the shared memory (/dev/shm)."
  echo "    Default: 0."
  #---
  optxt "rmdir \"0|1|yes|no\""; envvartxt REMOVE_DIR "(optional)."; echo
  echo "    Set this option to remove the internally created work directories."
  echo "    Default: 0."
  #---
  optxt "clean \"0|1|yes|no\""; envvartxt CLEANUP "(optional)."; echo
  echo "    Set this option to clean all intermediate files created during this simulation."
  echo "    Default: 1."

  export COLORSET=${old_COLORSET:-}

  exit 0
}

UnsetParseEnvVars()
{
  local nm_func="${FUNCNAME[0]}"

  local ival def_evars all_evars

  def_evars="CASEID BEG_DATE END_DATE DATE DATE_FMT
             CAST_CYCLE CAST_INIT_DAYS CAST_LENGTH ATM_DATA_HOURS
             ROOT_DIR DATA_DIR DATA_INTERVAL INP_DIR OUT_DIR BATH_DIR
             BDRY_DIR FRC_DIR INI_DIR LOGS_DIR WGHT_DIR IDL_DIR
             MATLAB_DIR PLOTS_DIR WEB_DIR WPS_DIR GEOG_DIR
             DOMS INI_FILES BDRY_FILES HOSTFILE CONF_FILE MODEL_INP
             FORCE_INI MODFILES USER_CPUS FILE_PFX FILE_SFX FILE_TYPE
             VTABLE_SFX LIST_DIR USE_GPAR GPAR_JOBS GPAR_SLF USE_SHMEM
             REMOVE_DIR CLEANUP PRINT_ENV"

  all_evars="$( echo ${*} )"
  [ -z "${all_evars:-}" ] && all_evars="$( echo ${def_evars} )"

  for ival in ${all_evars}
  do
    export ${ival}=
  done
  
  return 0
}
############################################################


############################################################
##### ERROR FUNCTIONS
############################################################
# -------------------------------------------------------
# forceError()
# Usage:      forceError message (optional)
# Parameters:
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : NONE
#
# forceError: A general force error function.
# -------------------------------------------------------
forceError()
{
  local -i status=1

  [ "X${1}" != "X" ] && echo -n  "${1}"

  exit ${status}
}

# -------------------------------------------------------
# procError()
# Usage:      procError message
#             procError "message1" \
#                       "message2" \
#                       .          \
#                       .          \
#                       .          \
#                       "messageN"
# Parameters:
#   message : The list of messages (strings) to display
#
# Returns : 1 (failure) or exits with code 1
#
# Exports : NONE
#
# Echoes  : On exit displays the supplied message with
#           the "ERROR" heading.
#
# procError: Force exit (code 1) on error and display the error message.
# -------------------------------------------------------
procError()
{
  # These are for the current function (procError)
  local fnm0="${FUNCNAME[0]}"
  local snm0="$( basename "${BASH_SOURCE[0]}" )"

  # These are for the calling function(s)
  local err_str fun_str src_str
  local fnm1="${FUNCNAME[1]}"
  local fnm2="${FUNCNAME[2]}"
  local fnm3="${FUNCNAME[3]}"
  local fnm4="${FUNCNAME[4]}"
  local snm1="$( basename "${BASH_SOURCE[1]}" )"
  local snm2="$( basename "${BASH_SOURCE[2]}" )"
  local snm3="$( basename "${BASH_SOURCE[3]}" )"
  local snm4="$( basename "${BASH_SOURCE[4]}" )"

  # proc_str: strings to be displayed (if supplied)
  # trim_str: trimmed version of proc_str
  local trim_str proc_str=( "$@" )
  local -i istr


  # Strings that identify the calling functions and sources
  cfnm="${fnm2:+${fnm2}:}${fnm3:+${fnm3}:}${fnm4:+${fnm4}:}"
    cfnm="${cfnm:+(${cfnm%:})}"
  csnm="${snm2:+${snm2}:}${snm3:+${snm3}:}${snm4:+${snm4}:}"
    csnm="${csnm:+(${csnm%:})}"

  src_str="${snm1}${csnm:+ ${csnm}}"
  fun_str="${fnm1}${cfnm:+ ${cfnm}}"

  err_str="${fun_str:+${fun_str}: }${src_str:+called from: ${src_str}}"
  [ -z "${err_str:-}" ] && \
    err_str="${fnm0:+${fnm0}: }${snm0:+defined in: ${snm0}}"

  # Display everything and then issue the exit command
  [ -n "${err_str:+1}" ] && echo "ERROR:: ${err_str}"
  for ((istr = 0; istr < ${#proc_str[@]}; istr++))
  do
    trim_str="$( strTrim "${proc_str[${istr}]}" 2)"
    [ -n "${trim_str:+1}" ] && echo "        ${proc_str[${istr}]}"
  done
  echo "        Exiting now ..."
  echo
  if [ -n "${PS1:+1}" ]; then
    return 1
  else
    exit 1
  fi
}

# -------------------------------------------------------
# procWarn()
# Usage:      procWarn message
#             procWarn "message1" \
#                      "message2" \
#                      .          \
#                      .          \
#                      .          \
#                      "messageN"
# Parameters:
#   message : The list of messages (strings) to display
#
# Returns : 0 (success)
#
# Exports : NONE
#
# Echoes  : Displays the supplied warning message with
#           the "WARN" heading.
#
# procWarn: Issue a warning message.
# -------------------------------------------------------
procWarn()
{
  # These are for the current function (procError)
  local fnm0="${FUNCNAME[0]}"
  local snm0="$( basename "${BASH_SOURCE[0]}" )"

  # These are for the calling function(s)
  local func_str=
  local fnm1="${FUNCNAME[1]}"
  local fnm2="${FUNCNAME[2]}"
  local fnm3="${FUNCNAME[3]}"
  local fnm4="${FUNCNAME[4]}"
  local snm1="$( basename "${BASH_SOURCE[1]}" )"
  local snm2="$( basename "${BASH_SOURCE[2]}" )"
  local snm3="$( basename "${BASH_SOURCE[3]}" )"
  local snm4="$( basename "${BASH_SOURCE[4]}" )"

  # proc_str: strings to be displayed (if supplied)
  # trim_str: trimmed version of proc_str
  local trim_str= proc_str=( "$@" )
  local -i istr


  # Strings that identify the calling functions and sources
  cfnm="${fnm2:+${fnm2}:}${fnm3:+${fnm3}:}${fnm4:+${fnm4}:}"
    cfnm="${cfnm:+(${cfnm%:})}"
  csnm="${snm2:+${snm2}:}${snm3:+${snm3}:}${snm4:+${snm4}:}"
    csnm="${csnm:+(${csnm%:})}"

  func_str="${fnm1}${cfnm:+ ${cfnm}}: called from: ${snm1}${csnm:+ ${csnm}}"


  # Display everything and then issue the exit command
  [ -n "${func_str:+1}" ]  && echo "WARN:: ${func_str}"
  for ((istr = 0; istr < ${#proc_str[@]}; istr++))
  do
    trim_str="$( strTrim "${proc_str[${istr}]}" 2)"
    [ -n "${trim_str:+1}" ] && echo "        ${proc_str[${istr}]}"
  done
  echo
  return 0
}

TaskError()
{
  local TheTask=

  TheTask="${1}"

  procError "the assigned task \"${TheTask}\" failed" \
            "please check the log files in: ${LogDir}"
}

TaskFound()
{
  local TheTask=

  TheTask="${1}"

  if [ -f "${TheTask}" ]; then
    chmod 0755 "${TheTask}"
    if [ $? -ne 0 ]; then
      procError "could not change permissions for:" \
                "TASK_TO_RUN = ${TheTask:-UNKNOWN}"
    fi
  else
    procError "task file not found:" \
              "TASK_TO_RUN = ${TheTask:-UNKNOWN}"
  fi
}
############################################################


############################################################
##### PROCESSES UTILITY FUNCTIONS
############################################################
# -------------------------------------------------------
# dokill()
# Usage:      dokill ProcessID
# Parameters: ProcessID (positive integer), the pid of the process
# Returns:    NONE
# Echoes:     NONE
#
# Kills the parent process and all its children.
# -------------------------------------------------------
dokill()
{
  local nm_func="${FUNCNAME[0]}"

  local -i cpid pid

  if [[ $# == 0 ]]; then
    procError "need to define the ProcessID" \
              "usage: ${nm_func} ParentID"
  fi

  for cpid in $(ps -o pid= --ppid $1)
  do
    dokill $cpid
  done
  echo "killing: $(ps -p $1 -o cmd=)"
  kill -9 $1 >/dev/null 2>&1
}

# -------------------------------------------------------
# getProcPid()
# Usage:      getProcPid ProcessName
# Parameters: ProcessName (string), the name of the process
# Returns:    1 on failure
#             0 on success
# Echoes:     the pid of the process
#
# Determines the PID of a process.
# -------------------------------------------------------
getProcPid()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0
  local user="$( id -un )" pid

  if [ $# -lt 1 ]; then
    procError "need to define the ProcessName" \
              "usage: ${nm_func} ProcessName"
  fi

  if [ "X${2}" != "X" ]; then
    user="${2}"
  fi

  pid="$( ps aux | grep -e "${1}" | grep "^${user}" | grep -v grep | awk '{print $2}' )"
  [ "X${pid}" = "X" ] && { pid=-1; retval=1; }

  echo -n ${pid}

  return ${retval}
}

# -------------------------------------------------------
# waitForProcesses()
# Usage:      waitForProcesses ProcessList [options]
# Parameters: ProcessList (string), the list of process names
# Parameters: --sleep=SLEEP (SLEEP: positive integer in seconds)
# Parameters: --timeout=TIMEOUT (TIMEOUT: positive integer in seconds)
# Returns:    1 on failure (eg., ProcessList is empty)
#             0 on success
# Echoes:     NONE
#
# Waits for all processes to complete. If the wait time is greater
# that TIMEOUT, it kills all processes still running and exits
# issuing exit 1.
# -------------------------------------------------------
waitForProcesses()
{
  local processes= proc_str= iproc=
  local inp_val= echo_char=
  local user pids ipid opt_opt opt_arg
  local -i nPROC=999999
  local -i time_sleep=20 time_out=3600 time_count=0
  local -i do_echo=0 retval=0

  local opt_all opt_opt opt_arg


  # ----- Get all the arguments
  processes="$( echo "${1}" )"
  [ "X${processes}" = "X" ] && return 1


  # -----
  # Process the function options
  opt_all=( sleep timeout user echo )
  opt_all=":$( echo "${opt_all[@]/#/-} ${opt_all[@]/#/--}" | sed 's/ /:/g' ):"

  __OPTION_LIST=
  while test $# -gt 1; do
    case "${2}" in
      -[^-]*=* | --[^-]*=* )
        opt_opt="$( toLOWER "$( echo "${2}" | sed 's/=.*//' )" )"
        opt_arg="$( strTrim "$( echo "${2}" | sed 's/.*=//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      -[^-]* | --[^-]* )
        opt_opt="$( toLOWER "${2}" )"
        opt_arg="$( strTrim "$( echo "${3}" | sed 's/=.*//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      *)
        opt_opt= 
        opt_arg=
        ;;
    esac

    case "${opt_opt}" in
      -sleep | --sleep )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          opt_arg=$( echo "${opt_arg}" | sed -e 's/[[:space:]]//g' )
          if [ "X${opt_arg}" != "X" ]; then
            inp_val="$( getPosInteger "${opt_arg}" )"
            time_sleep="${inp_val:-${time_sleep}}"
          fi
        ;;
      -timeout | --timeout )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          opt_arg=$( echo "${opt_arg}" | sed -e 's/[[:space:]]//g' )
          if [ "X${opt_arg}" != "X" ]; then
            inp_val="$( getPosInteger "${opt_arg}" )"
            time_out="${inp_val:-${time_out}}"
          fi
        ;;
      -user | --user )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          opt_arg=$( echo "${opt_arg}" | sed -e 's/[[:space:]]//g' )
          if [ "X${opt_arg}" != "X" ]; then
            user="${opt_arg}"
          fi
        ;;
      -echo | --echo )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          do_echo=1
        ;;
      *) ;; # DEFAULT
    esac
    shift
    opt_opt= 
    opt_arg=
  done
  __OPTION_LIST=
  # -----


  [ "X${user}" = "X" ] &&  user="$( id -un )"

  # ----- Start the calculations
  for i in ${processes}
  do
    proc_str="${proc_str}${i}|"
  done
  proc_str=$( echo "${proc_str}" | sed 's/[|]*$//' )

  while [ ${nPROC} -ne 0 ]
  do
    if [ ${time_count} -gt ${time_out} ]; then
      echo
      echo "ERROR:: waitForProcesses: Time out exceeded (${time_out})."

      iproc=
      for iproc in ${processes}
      do
        if [ $( ps aux | grep -v grep | grep "^${user}" | egrep -c "${iproc}" ) -ne 0 ]; then
          if [ "X${iproc}" != "X" ]; then
            echo "        killing process: ${iproc:-UNDEF}"
            pids="$( getProcPid "${iproc}" "${user}" )"
            for ipid in ${pids} ; do dokill "${ipid}" ; done
          fi
        fi
      done
      echo "        Exiting now ..."
      echo -n
      exit 1
    fi

    nPROC=$( ps aux | grep -v grep | grep "^${user}" | egrep -c "${proc_str}" )
    
    if [ ${nPROC} -ne 0 ]; then
      if [ ${do_echo} -gt 0 ]; then
        echo_char="#"
        echo -n ${echo_char}
       fi
      time_count=$(( time_count + time_sleep ))
      sleep ${time_sleep}
    fi
  done
  [ -n "${echo_char:+1}" ] && echo

  return 0
}
############################################################


############################################################
##### GENERAL UTILITY FUNCTIONS
############################################################
# -------------------------------------------------------
# getYesNo()
# Usage:      getYesNo value
# Parameters:
#   value : The input value (the value of a parameter)
#           The value of a bash parameter that is checked
#           against TRUE/FALSE. If the value is one of:
#             ">=1|y|yes|yea|yeah|yep"
#           then the value of parameter is TRUE (answer = yes).
#           If the value is one of:
#             "<=0|n|no|not|nop|nope"
#           then the value of parameter is FALSE (answer = no).
#           If the value is empty then the value of parameter
#           is FALSE (answer = no)
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : A "yes" or "no" answer.
#
# getYesNo: Checks if a parameter is assigned a TRUE/FALSE value.
# -------------------------------------------------------
getYesNo()
{
  local param answer
  
  param="$( echo "${1}" | tr '[:upper:]' '[:lower:]' )"

  if [ "${param}" -eq "${param}" ] 2>/dev/null
  then
    [ ${param} -le 0 ] && param=0
    [ ${param} -gt 0 ] && param=1
  fi

  case "${param}" in
    1|y|yes|yea|yeah|yep) answer="yes" ;;
     0|n|no|not|nop|nope) answer="no"  ;;
                       *) answer="no"  ;; # DEFAULT
  esac

  echo -n ${answer}
}

# -------------------------------------------------------
# adjustYESNOVar()
# Usage:      adjustYESNOVar parameter
# Parameters:
#   parameter : The input parameter to check and adjust
#               The value of the input parameter is checked
#               against TRUE/FALSE. IfunsetEnvVars its value is FALSE
#               then the parameter is unset.
#               (See the getYesNo function)
#
# Returns : 0 (success)
#
# Exports : The adjusted parameter value. If the value is determined
#           to be TRUE, the parameter is set to "yes" otherwise
#           the parameter is unset
#
# Echoes  : NONE
#
# adjustYESNOVar: Assign a parameter a TRUE=yes/FALSE=empty value.
# -------------------------------------------------------
adjustYESNOVar()
{
  local nm_func="${FUNCNAME[0]}"

  local varLIST var val

  [ $# -eq 0 ] && return 0

  varLIST="${*}"

  for var in ${varLIST}
  do
    val="$( eval "echo \$$(echo ${var})" )"
    val="$( getYesNo "${val:-no}" )"

#    export ${var}=${val}
#    [ "${val:-no}" = "no" ] && unset ${var}

    eval "${var}=\${val}"
    [ "${val:-no}" = "no" ] && unset ${var}
    export ${var}
  done

  return 0
}

# -------------------------------------------------------
# unsetEnvVars()
# Usage:      unsetEnvVars parameter
# Parameters:
#   parameter : The input parameter to check and unset.
#
# Returns : 0 (success)
#
# Exports : The adjusted parameter value.
#
# Echoes  : NONE
#
# unsetEnvVars: Set a parameter to an empty value.
# -------------------------------------------------------
unsetEnvVars()
{
  local nm_func="${FUNCNAME[0]}"

  local varLIST var val

  [ $# -eq 0 ] && return 0

  varLIST="${*}"

  for var in ${varLIST}
  do
    eval "${var}="
    export ${var}
  done

  return 0
}

function StartWatch()
{
  export WATCH_START_DATE="$( date )"
  export WATCH_START_TIME="$( date -d "${WATCH_START_DATE}" "+%s" )"
}

function StopWatch()
{
  local elps_time start_time stop_time msg=

  export WATCH_STOP_DATE="$( date )"
  export WATCH_STOP_TIME="$( date -d "${WATCH_STOP_DATE}" "+%s" )"

  msg="${1}"
  [ "X${msg}" != "X" ] && msg="${msg} "

  start_time=${WATCH_START_TIME:-0}
  stop_time=${WATCH_STOP_TIME:-0}

  elps_time="$( echo "scale=6; (${stop_time} - ${start_time}) / 60.0" | bc -ql 2>/dev/null )"
  elps_time="$( echo ${elps_time} | awk '{printf "%5.1f", $0}' )"
  elps_time="$( strTrim "${elps_time}" 2 ) min"
  
  echo "${msg}${elps_time}"
}

# -------------------------------------------------------
# strESC()
# Usage:      strESC string
# Parameters:
#   string : The input string
#            The input string on which this function is applied
#            to escape special characters used in bash/sed ...
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : The modified string with its special characters escaped
#
# strESC: Escapes special characters in a string: "'()/[]*.
# -------------------------------------------------------
strESC()
{
  echo -n "$( echo "${*}" | sed -e "s/[\"\'\(\)\/\*\!]/\\\&/g;s/\[/\\\&/g;s/\]/\\\&/g" )"
}

strESC1()
{
  echo -n "$( echo "${*}" | sed -e "s/[\&\/\*\!]/\\\&/g;s/\[/\\\&/g;s/\]/\\\&/g" )"
}

# -------------------------------------------------------
# strRmDuplicate()
# Usage:      strRmDuplicate string
# Parameters:
#   string : The input string
#            The input string that can contain a list of substrings
#            separated by spaces, in which duplicate substrings
#            are removed without sorting the remaining entries
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : The modified string without duplicate substrings
#
# strRmDuplicate: Removes duplicate sub-strings from string
#                 without sorting the remaining entries.
# -------------------------------------------------------
strRmDuplicate()
{
  local sep_str="${2:-[[:space:]]}"

  echo -n $( echo "${1}" | tr "${sep_str}" "\n" | \
             awk '{if ($1 in a) next; a[$1]=$0; print}' | \
             tr "\n" " " )
}

# -------------------------------------------------------
# strSort()
# Usage:      strSort string
# Parameters:
#   string : The input string
#            The input string that can contain a list of substrings
#            separated by spaces, in which duplicate substrings
#            are removed while sorting the remaining entries
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : The modified string without duplicate substrings
#
# strSort: Removes duplicate sub-strings from string and sorts
#          the remaining entries.
# -------------------------------------------------------
strSort()
{
  local sep_str="${2:-[[:space:]]}"

  echo -n $( echo "${1}" | tr "${sep_str}" "\n" | \
             sort -u | tr "\n" " " )
}

# -------------------------------------------------------
# strstr()
# Usage:      strstr s1 s2
# Parameters:
#   s1 : The input string
#   s2 : The sub-string in s1
#
# Returns : 1 if s2 does not occur in s1 (failure)
#           0 in any other case (success)
#
# Exports : NONE
#
# Echoes  : A substring starting at the first occurrence
#           of string s2 in string s1, or nothing if s2
#           does not occur in s1. If s2 points to a string
#           of zero length, strstr echoes s1.
#
# strstr: Extracts a sub-string from the input string.
# -------------------------------------------------------
function strstr ()
{
  local -i retval=0
  local first=

# if s2 points to a string of zero length, strstr echoes s1
  if [ ${#2} -eq 0 ]; then
    echo -n "${1}"
    return ${retval}
  fi

# strstr echoes nothing if s2 does not occur in s1
  case "$1" in
  *$2*) ;;
     *) return ${retval};;
  esac

# use the pattern matching code to strip off the match and everything
# following it
  first=${1/$2*/}

# then strip off the first unmatched portion of the string
  echo -n "${1##$first}"

  return ${retval}
}

# -------------------------------------------------------
# strTrim()
# Usage:      strTrim s1 flag
# Parameters:
#     s1 : The input string
#   flag : Integer
#          A value that controls the action of strTrim.
#          If flag is zero or not present, trailing blanks are removed.
#          Leading blanks are removed if it is equal to 1.
#          Both are removed if it is equal to 2.
#          In any other case, trailing blanks are removed.
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : s1 with all leading and/or trailing
#           white spaces removed.
#
# strTrim: Removes all leading and/or trailing white spaces
#          from the input string
# -------------------------------------------------------
function strTrim ()
{
  local trimFLG="${2:-0}"
  local out_str=

  case ${trimFLG} in
    0) out_str="$(echo "${1}" | sed 's/[[:space:]]*$//')" ;;
    1) out_str="$(echo "${1}" | sed 's/^[[:space:]]*//')" ;;
    2) out_str="$(echo "${1}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')" ;;
    *) out_str="$(echo "${1}" | sed 's/[[:space:]]*$//')" ;;
  esac

  echo -n ${out_str}
}

# -------------------------------------------------------
# checkSUBSTR()
# Usage:      checkSUBSTR s1 s2
# Parameters:
#   s1 : The input string
#   s2 : The sub-string in s1
#
# Returns : 1 if s2 does not occur in s1 (failure)
#           0 if s2 occurs in s1 (success)
#
# Exports : NONE
#
# Echoes  : NONE
#
# checkSUBSTR: Checks for a sub-string in the input string
# -------------------------------------------------------
function checkSUBSTR()
{
  [ $# -lt 2 ] && return 1

  case "${1}" in
    *"${2}"*) return 0 ;;
           *) return 1 ;; # NO MATCH (error)
  esac
}

# -------------------------------------------------------
# toUPPER()
# Usage:      toUPPER string
# Parameters:
#   string : The string in to convert
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : The input string converted to an all upper case string
#
# toUPPER: Converts a string to an all upper case string
# -------------------------------------------------------
function toUPPER()
{
  echo "${1}" | tr '[:lower:]' '[:upper:]'
}

# -------------------------------------------------------
# toLOWER()
# Usage:      toLOWER string
# Parameters:
#   string : The string in to convert
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : The input string converted to an all lower case string
#
# toLOWER: Converts a string to an all lower case string
# -------------------------------------------------------
function toLOWER()
{
  echo "${1}" | tr '[:upper:]' '[:lower:]'
}

# -------------------------------------------------------
# ModifyAVar()
# Usage:      ModifyAVar file_name var_name var_value
# Parameters:
#   file_name: The filename to use (text file)
#   var_name : The name of the variable to modify in file_name
#   file_name: The new value of the variable var_name
#
# Returns : NONE
#
# Exports : NONE
#
# Echoes  : NONE
#
# ModifyAVar: Modifies the value of a variable in the input file.
# -------------------------------------------------------
ModifyAVar()
{
  local nm_func="${FUNCNAME[0]}"

  local fname vname vvalue
  local xpr1 xpr2

  if [ $# -lt 3 ]; then
    procError "need to define the filename, the variable and its value to modify" \
              "usage: ${nm_func} fname vname vvalue"
  fi

  if [ ! -f "${1}" ]; then
    procError "need to define a valid filename" \
              "usage: ${nm_func} fname vname vvalue"
  fi

  fname="${1}"
  vname="$( strESC "$( echo "${2}" | sed 's/[[:space:]]//g' )" )"
  vvalue="$( strESC "${3}" )"

  isNumber "${vvalue}"
  if [ $? -ne 0 ]; then
    if [ -n "${vvalue:+1}" ]; then
      vvalue="\"${vvalue}\""
    else
      vvalue="${vvalue}"
    fi
  fi

  xpr1="^[[:space:]]*${vname}[[:space:]]*=[[:space:]]*"
  xpr2="${vvalue}"
  sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${fname}
}

# -------------------------------------------------------
# checkFuncOpt()
# Usage:      checkFuncOpt opt_name
# Parameters:
#   opt_name: The name of the option to a function
#
# Returns : Exits on error
#
# Exports : __OPTION_LIST
#
# Echoes  : NONE
#
# checkFuncOpt: Checks if an option to a function is already supplied.
# -------------------------------------------------------
checkFuncOpt() {
  local opt_inp opt

  [ $# -eq 0 ] && return 0

  opt_inp="${1}"

  # Check it's not already in use
  for opt in ${__OPTION_LIST}
  do 
    if [ "${opt_inp}" = "${opt}" ]; then
      procError "Option name \"${opt_inp}\" is already in use"
    fi
  done

  __OPTION_LIST="${__OPTION_LIST} ${opt_inp}"
  export __OPTION_LIST
}

# -------------------------------------------------------
# getSHMDEV()
# Usage:      getSHMDEV size
# Parameters:
#   size : The size in GB of required storage in the device,
#          a positive number in GB (default 20GB , if size is not supplied)
#          In any other case size is set to 0.
#
# Returns : 0 (success), 1 (failure)
#
# Exports : NONE
#
# Echoes  : The shared device name (/dev/shm in Linux) if all conditions
#           are met (success) or a warning  message in any other case (failure)
#
# getSHMDEV: Checks if the shared device is availabe to the caller
# -------------------------------------------------------
getSHMDEV()
{
  local nm_func="${FUNCNAME[0]}"

  local tmpDEVFS shmDEV=/dev/shm

  # In GB
  local def_space=20
  local avl_space req_space

  local -i bsize=1024 chk_val


  req_space=${1:-${def_space}}
  if ! $( isPosNumber "${req_space}" ); then
    req_space=0
  fi


  if $( grep -qs "${shmDEV}" /proc/mounts ); then
    tmpDEVFS=${shmDEV}
    if $( ! checkDIR -rwx "${tmpDEVFS}" ); then
      tmpDEVFS="${nm_func}: ${shmDEV} exists but read/write/execute permissions are not valid"
      echo -n ${tmpDEVFS}
      return 1
    fi
  else
    tmpDEVFS="${nm_func}: ${shmDEV} is not a mounted filesystem"
    echo -n ${tmpDEVFS}
    return 1
  fi

  # After reaching here, we check if there is enough availabe space in shmDEV
  # Available space in bytes
  avl_space=$( df --block-size=${bsize} ${tmpDEVFS} | \
                 awk 'NR==2' | awk '{print $4}' )
  # Convert to GB
  avl_space="$( echo "${avl_space} / (${bsize} * ${bsize})" | bc -ql 2>/dev/null )"

  # Check if available space is greater or equal to requested space
  # chk_val: 1=TRUE, 0=FALSE
  chk_val="$( echo "${avl_space} >= ${req_space}" | bc -ql 2>/dev/null )"

  if [ ${chk_val} -ne 1 ]; then
    avl_space="$( echo "scale=3; ${avl_space} / 1.0" | bc -ql 2>/dev/null )"
    tmpDEVFS="${nm_func}: Available space (${avl_space} GB) in ${shmDEV} is less than requested: ${req_space} GB"
    echo -n ${tmpDEVFS}
    return 1
  fi

  echo -n ${tmpDEVFS}

  return 0
}

# -------------------------------------------------------
# LoadEnvModules()
# Usage:      LoadEnvModules mlist
#
# Parameters:
# mlist : The list of environment modules to load.
#
# Returns : 0 (success), 1 (failure)
# Exports : NONE
# Echoes  : NONE
#
# Removes all previously loaded environment modules and loads
# all modules in "mlist".
# On error, echoes an error message and exits the current scope.
# -------------------------------------------------------
LoadEnvModules()
{
  local imod mods
  local chkMOD myMODULE myMODULECMD

  [ $# -eq 0 ] && return 0

  mods="${@}"


  # -----
  # Find if modulecmd exists in this OS.
  # If the package environment modules is installed, then
  # "modulecmd" should be in the PATH of the user
  # Exit this function if modulecmd is not found
  myMODULECMD=$( command -v modulecmd 2>&1 )
  if [ $? -ne 0 ]; then
    procWarn "Could not find the program \"modulecmd\"" \
             "Is package \"environment modules\" installed in this OS?" \
             "The requested modules: ${mods} cannot be loaded."
    return 1
  fi
  # -----


  # Try to load the requested modules.
  myMODULE=module
  chkMOD=$( command -v ${myMODULE} 2>&1 )
  [ $? -ne 0 ] && module() { eval $( ${myMODULECMD} sh $* ); }

  [ -n "${LOG_SCRIPT:+1}" ] && \
    echo "Removing all loaded modules" >> ${LOG_SCRIPT}

  ${myMODULE} purge >/dev/null 2>&1
  [[ ! :$PATH: == *:".":* ]] && export PATH="${PATH}:."

  for imod in ${mods}
  do
    chkMOD=
    ${myMODULE} load "${imod}" >/dev/null 2>&1
    chkMOD="$( echo "${LOADEDMODULES}" | egrep -o "${imod}" )"

    if [ -z "${chkMOD}" ]; then
      [ -n "${LOG_SCRIPT:+1}" ] && \
        echo "Failed to load the requested module: ${imod}"

      procError "Failed to load the requested module: ${imod}"
      return 1
    else
      [ -n "${LOG_SCRIPT:+1}" ] && \
        echo "Loaded module: ${imod}"
    fi
  done

  return 0
}
############################################################


############################################################
##### YEAR/DAY UTILITY FUNCTIONS
############################################################
# -------------------------------------------------------
# getYearDays()
# Usage:      getYearDays year
# Parameters: year (year >= 0)
# Returns:    NONE
# Echoes:     the number of the days in the year (365/366)
#             if year is not a valid positive integer
#             (including 0) echoes an empty string
# -------------------------------------------------------
getYearDays()
{
  local -i retval=0
  local echoval=

  if [ "X$( getPosInteger ${1} )" != "X" ]; then
    echoval=365
    if [ $( expr ${1} % 4 ) = 0 ]  &&
       [ $( expr ${1} % 100 ) != 0 ] ||
       [ $( expr ${1} % 400 ) = 0 ] ; then
         echoval=366
    fi
  else
    retval=1
  fi

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# getMonthDays()
# Usage:      getMonthDays year month
# Parameters: year (year >= 0)
#             month (1 <= month <= 12)
# Returns:    NONE
# Echoes:     the number of the days in the month of the year
#             if year is not a valid positive integer
#             (including 0) echoes an empty string
# -------------------------------------------------------
getMonthDays()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0 yrDAYS=0 myMO=0
  local echoval=

  if [ $# -lt 2 ]; then
    procError "need to define the year and the month" \
              "usage: ${nm_func} year month"
  fi

  yrDAYS="$( getYearDays ${1} )"
  if [ $? -ne 0 ]; then
    procError "wrong year"
  fi

  myMO="$( getPosInteger ${2} )"
    [ -z "${myMO:-}" ] && myMO=0
  [ ${myMO} -lt 1 -o ${myMO} -gt 12 ] && myMO=0

  case ${myMO} in
     1) echoval=31 ;;
     2) echoval=28
        [ ${yrDAYS} -eq 366 ] && echoval=29
        ;;
     3) echoval=31 ;;
     4) echoval=30 ;;
     5) echoval=31 ;;
     6) echoval=30 ;;
     7) echoval=31 ;;
     8) echoval=31 ;;
     9) echoval=30 ;;
    10) echoval=31 ;;
    11) echoval=30 ;;
    12) echoval=31 ;;
     *) procError "wrong month" ;;
  esac

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# getYearString()
# Usage:      getYearString year
# Parameters: year (9999 >= year >= 0)
# Returns:    NONE
# Echoes:     the zero padded string of the year that is,
#             0001, 0015, 0232, 1325, ...
#             if year is not a valid positive integer
#             echoes an empty string
# -------------------------------------------------------
getYearString()
{
  local -i retval=0
  local echoval=

  if [ "X$( getPosInteger ${1} )" != "X" ]; then
    [ ${1} -lt 10   ]                       && echoval="000${1}"
    [ ${1} -ge 10   ] && [ ${1} -lt 100   ] && echoval="00${1}"
    [ ${1} -ge 100  ] && [ ${1} -lt 1000  ] && echoval="0${1}"
    [ ${1} -ge 1000 ] && [ ${1} -lt 10000 ] && echoval="${1}"
  else
    retval=1
  fi

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# getDayString()
# Usage:      getDayString day
# Parameters: day (366 >= day >= 0)
# Returns:    NONE
# Echoes:     the zero padded string of the day that is,
#             001, 015, 232, ...
#             if day is not a valid positive integer
#             echoes an empty string
# -------------------------------------------------------
getDayString()
{
  local -i retval=0
  local echoval=

  if [ "X$( getPosInteger ${1} )" != "X" ]; then
    [ ${1} -lt 10  ]                     && echoval="00${1}"
    [ ${1} -ge 10  ] && [ ${1} -lt 100 ] && echoval="0${1}"
    [ ${1} -ge 100 ] && [ ${1} -le 366 ] && echoval="${1}"
  else
    retval=1
  fi

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# getHourString()
# Usage:      getHourString hour
# Parameters: hour (23 >= hour >= 0)
# Returns:    NONE
# Echoes:     the zero padded string of the hour that is,
#             00, 09, 12, ...
#             if hour is not a valid positive integer
#             (including 0) echoes an empty string
# -------------------------------------------------------
getHourString()
{
  local -i retval=0
  local echoval=

  if [ "X$( getPosInteger ${1} )" != "X" ]; then
    [ ${1} -lt 10 ] && echoval="0${1}"
    [ ${1} -ge 10 ] && [ ${1} -le 24  ] && echoval="${1}"
  else
    retval=1
  fi

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# get2DString()
# Usage:      get2DString number (integer)
# Parameters: number (99 >= number >= 0)
# Returns:    NONE
# Echoes:     the zero padded string of the number that is,
#             00, 09, 12, ...
#             if number is not a valid positive integer
#             (including 0) echoes an empty string
# -------------------------------------------------------
get2DString()
{
  local -i retval=0
  local echoval=

  if [ "X$( getPosInteger ${1} )" != "X" ]; then
    [ ${1} -lt 10 ] && echoval="0${1}"
    [ ${1} -ge 10 ] && [ ${1} -le 99 ] && echoval="${1}"
  else
    retval=1
  fi

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# get3DString()
# Usage:      get3DString number (integer)
# Parameters: number (999 >= number >= 0)
# Returns:    NONE
# Echoes:     the zero padded string of the number that is,
#             000, 009, 012, ...
#             if number is not a valid positive integer
#             (including 0) echoes an empty string
# -------------------------------------------------------
get3DString()
{
  local -i retval=0
  local echoval=

  if [ "X$( getPosInteger ${1} )" != "X" ]; then
    [ ${1} -lt  10 ] && echoval="00${1}"
    [ ${1} -ge  10 ] && [ ${1} -le  99 ] && echoval="0${1}"
    [ ${1} -ge 100 ] && [ ${1} -le 999 ] && echoval="${1}"
  else
    retval=1
  fi

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# get4DString()
# Usage:      get4DString number (integer)
# Parameters: number (9999 >= number >= 0)
# Returns:    NONE
# Echoes:     the zero padded string of the number that is,
#             0000, 0009, 0012, ...
#             if number is not a valid positive integer
#             (including 0) echoes an empty string
# -------------------------------------------------------
get4DString()
{
  local -i retval=0
  local echoval=

  if [ "X$( getPosInteger ${1} )" != "X" ]; then
    [ ${1} -lt  10  ] && echoval="000${1}"
    [ ${1} -ge  10  ] && [ ${1} -le  99  ] && echoval="00${1}"
    [ ${1} -ge 100  ] && [ ${1} -le 999  ] && echoval="0${1}"
    [ ${1} -ge 1000 ] && [ ${1} -le 9999 ] && echoval="${1}"
  else
    retval=1
  fi

  echo -n ${echoval}

  return ${retval}
}
############################################################


############################################################
##### NUMBER UTILITY FUNCTIONS
############################################################
# -------------------------------------------------------
# isNumber()
# Usage:      isNumber var
# Parameters: var
# Returns:    1 if var is not a number (failure)
#             0 in any other case (success)
# Echoes:     NONE
# -------------------------------------------------------
isNumber()
{
  local -i retval=1
  local numb="${1}"

  local pat pat1 pat2

  # Remove leading/trailing whitespace characters. Approach 1
  #numb="$(echo "${1}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"

  # Remove leading/trailing whitespace characters. Approach 2
  numb="${numb#"${numb%%[![:space:]]*}"}"
  numb="${numb%"${numb##*[![:space:]]}"}"

  [ -z "${numb:-}" ] && return ${retval}

    pat1='[^0-9dDeE+\.\-]'
  [[ "${numb}" =~ ${pat1} ]] && return ${retval}

    pat1='^([-+]?[0-9]+)?([.][0-9]+)?([eE][-+]?[0-9]+)?$'
    pat2='^([-+]?[0-9]+)?([.][0-9]+)?([dD][-+]?[0-9]+)?$'
  for pat in ${pat1} ${pat2}
  do
    if  [[ "${numb}" =~ ${pat} ]] ; then
       retval=0
       break
    fi
  done

  return ${retval}
}

# -------------------------------------------------------
# isPosNumber()
# Usage:      isPosNumber var
# Parameters: var
# Returns:    1 if var is not a positive number (failure)
#             0 in any other case (success)
# Echoes:     NONE
# -------------------------------------------------------
isPosNumber()
{
  local -i retval=1
  local numb val

  [ $# -eq 0 ] && return ${retval}

  if $( isNumber "${1}" ); then
    numb="$( echo "${1}" | sed 's/[eEdD]/*10^/g;s/+//g' )"
    val="$(echo "${numb} >= 0" | bc -ql 2>/dev/null)"

    [ "${val:-0}" -eq 1 ] && retval=0
  fi

  return ${retval}
}

# -------------------------------------------------------
# isInteger()
# Usage:      isInteger var
# Parameters: var
# Returns:    1 if var is not an integer (0 is an integer as well)
#             0 in any other case
# Echoes:     NONE
# -------------------------------------------------------
isInteger()
{
  local -i retval=1

  [ $# -eq 0 ] && return ${retval}

  if [ "${1:-UNDEF}" -eq "${1}" ] 2>/dev/null
  then
    retval=0
  fi

  return ${retval}
}

# -------------------------------------------------------
# isLogical()
# Usage:      isLogical var
# Parameters: var
# Returns:    1 if var is not "true" or "false"
#             0 in any other case
# Echoes:     NONE
# -------------------------------------------------------
isLogical ()
{
  local -i retval=1
  local my_var

  [ $# -eq 0 ] && return ${retval}

  my_var="$( echo -e "${1:-UNDEF}" | tr '[:lower:]' '[:upper:]' )"

  if [ "${my_var}" = ".TRUE." -o "${my_var}" = ".FALSE." ] ; then
     retval=0
  fi

  return ${retval}
}

# -------------------------------------------------------
# getInteger()
# Usage:      getInteger int
# Parameters: int (int >=0 or, int < 0)
# Returns:    1 if var is not an integer
#             0 in any other case
# Echoes:     int, if it is a valid integer (including 0),
#             in any other case echoes an empty string
# -------------------------------------------------------
getInteger()
{
  local -i retval=0
  local echoval= minus=

  # strip spaces, '+' signs and '-' signs
  # if the first character of the string is '-', set the minus variable
  echoval="$( echo "${1}" | sed 's/[[:space:]+]//g' )"
  [ "X$( echo "${echoval:0:1}" )" = "X-" ] && minus="-"
  echoval="${minus}$( echo "${echoval}" | sed 's/[[:space:]-]//g' )"

  if isInteger ${echoval}; then
    echoval="$(echo "scale=0; ${echoval} + 0" | bc -ql 2>/dev/null)"
    retval=$?
    echoval="${echoval:-0}"
  else
    echoval=
    retval=1
  fi

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# getPosInteger()
# Usage:      getPosInteger posint
# Parameters: posint (posint >= 0)
# Returns:    1 if var is not a positive integer
#             0 in any other case
# Echoes:     posint if it is a valid positive integer
#             (including 0), in any other case echoes an
#             empty string
# -------------------------------------------------------
getPosInteger()
{
  local -i retval=0
  local echoval=

  echoval=$( getInteger "${1}" )
  retval=$?

  if [ ${retval} -ne 0 ] ; then
    echoval=
    retval=1
  else
    if [ ${echoval} -lt 0 ]; then
      echoval=
      retval=1
    fi
  fi

  echo -n ${echoval}

  return ${retval}
}

# -------------------------------------------------------
# getNegInteger()
# Usage:      getNegInteger negint
# Parameters: negint (negint < 0)
# Returns:    1 if var is not a negative integer
#             0 in any other case
# Echoes:     negint if it is a valid negative integer,
#             in any other case echoes an empty string
# -------------------------------------------------------
getNegInteger()
{
  local -i retval=0
  local echoval=

  echoval=$( getInteger "${1}" )
  retval=$?

  if [ ${retval} -ne 0 ] ; then
    echoval=
    retval=1
  else
    if [ ${echoval} -ge 0 ]; then
      echoval=
      retval=1
    fi
  fi

  echo -n ${echoval}

  return ${retval}
}

min()
{
  local i myVAL= myLIST= chkLIST="$@"

  for i in ${chkLIST}
  do
    if $( isNumber "${i}" ); then
      if [ -z "${myLIST:-}" ]; then
        myLIST="${i}"
      else
        myLIST="${myLIST} ${i}"
      fi
    fi
  done

  if [ -n "${myLIST:+1}" ]; then
    myVAL="$( echo "${myLIST}" | tr [:space:] "\n" | \
              awk '{ if(val==""){val=$1}; if($1<val){val=$1} } END \
                   {print val}' )"
  fi

  echo -n ${myVAL}
}

min1()
{
  local -i i myVAL=9999999999
  local array=

  array=( $(echo "$@") )

  for ((i = 0; i < ${#array[@]}; i++))
  do
    if [ ${array[${i}]} -le ${myVAL} ]; then
      myVAL=${array[${i}]}
    fi
  done

  echo -n ${myVAL}
}

max()
{
  local i myVAL= myLIST= chkLIST="$@"

  for i in ${chkLIST}
  do
    if $( isNumber "${i}" ); then
      if [ -z "${myLIST:-}" ]; then
        myLIST="${i}"
      else
        myLIST="${myLIST} ${i}"
      fi
    fi
  done

  if [ -n "${myLIST:+1}" ]; then
    myVAL="$( echo "${myLIST}" | tr [:space:] "\n" | \
              awk '{ if(val==""){val=$1}; if($1>val){val=$1} } END \
                   {print val}' )"
  fi

  echo -n ${myVAL}
}

max1()
{
  local -i i myVAL=-9999999999
  local array=

  array=( $(echo "$@") )

  for ((i = 0; i < ${#array[@]}; i++))
  do
    if [ ${array[${i}]} -ge ${myVAL} ]; then
      myVAL=${array[${i}]}
    fi
  done

  echo -n ${myVAL}
}

String_FormDbl()
{
  local -i retval=0
  local in_str def_val out_str

  in_str="${1}"
  def_val="${2}"
  out_str=

  if [ -n "${def_val:+1}" ]; then
    def_val="$(echo "${def_val}" | awk '{print $1}')d0"
  fi

  if [ -n "${in_str:+1}" ]; then
    out_str="$(echo "${in_str}" | awk '{print $1}')"
    [ "X$( strstr "${out_str}" "\." )" = "X" ] && \
      out_str="$(echo "${out_str}" | awk '{printf "%.1f", $1}')"
    out_str="$(echo ${out_str})d0"
  fi

  [ -z "${out_str:-}" ] && out_str="${def_val}"

  echo -n ${out_str}
}

String_getInteger()
{
  local -i retval=0
  local in_str def_val out_str

  in_str="${1}"
  def_val="${2}"
  out_str=

  if [ -n "${def_val:+1}" ]; then
    def_val="$(echo "${def_val}" | awk '{print $1}')"
    def_val="$(getInteger "${def_val}")"
  fi

  if [ -n "${in_str:+1}" ]; then
    out_str="$(echo ${in_str} | awk '{print $1}')"
    out_str="$(getInteger "${out_str}")"
  fi

  [ -z "${out_str:-}" ] && out_str="${def_val}"

  echo -n ${out_str}
}
############################################################


############################################################
##### FILE UTILITY FUNCTIONS
############################################################
# -------------------------------------------------------
# stripESCFILE()
# Usage:      stripESCFILE file
# Parameters: file (string)
#
# Returns :   NONE
# Echoes  :   NONE
# Exports :   NONE
#
# stripESCFILE deletes special characters in a file
#              currently backspace, carriage return
# -------------------------------------------------------
stripESCFILE()
{
  checkFILE -r "${1}"
  [ $? -ne 0 ] && return 0

  sed -i -e 's/[\x08\r]//g' "${1}"
}

# -------------------------------------------------------
# checkFILE()
# Usage:      checkFILE [options] file
# Parameters: file (string)
# Returns:    1 if the options are not met or, no arguments
#             were supplied or, the file is an empty string
#             0 in any other case (success)
# Echoes:     NONE
#
# Possible options are:
# -h FILE exists and is a symbolic link (same as -L)
# -L FILE exists and is a symbolic link (same as -h)
# -r FILE exists and is readable
# -s FILE exists and has a size greater than zero
# -w FILE exists and is writable
#
# Checks if the file "file" is a valid file
# based on the options supplied. If no options supplied
# it simply checks that if "file" is a a regular file
# -------------------------------------------------------
checkFILE()
{
  local -i retval=0
  local get_opts my_arg="" chk_my_arg="" my_opts="-f" iopt
# Use these to reset the options since the shell does not
# do that automatically
  local opt_id=${OPTIND} opt_arg="${OPTARG}"

  [ $# -eq 0 ] && { retval=1; return ${retval}; }

  while getopts ":hLrsw" get_opts
  do
    case ${get_opts} in
      h|L) my_opts="${my_opts} -h";;
        r) my_opts="${my_opts} -r";;
        s) my_opts="${my_opts} -s";;
        w) my_opts="${my_opts} -w";;
        *) ;; # DEFAULT
    esac
  done

# Get the first argument after the options
  shift $(( ${OPTIND} - 1))
  my_arg=${1}

# Reset the option variables since the shell doesn't do it
  OPTIND=${opt_id}
  OPTARG="${opt_arg}"

  chk_my_arg="$( echo "${my_arg##*/}" | sed -e 's/[[:space:]]//g' )"
  [ "X${my_arg}" = "X" ] && { retval=1; return ${retval}; }

  for iopt in ${my_opts}
  do
    [ ! ${iopt} "${my_arg}" ] && { retval=1; return ${retval}; }
  done

  return ${retval}
}

function toUPPER()
{
  echo "${1}" | tr '[:lower:]' '[:upper:]'
}

function toLOWER()
{
  echo "${1}" | tr '[:upper:]' '[:lower:]'
}

GetPathEnvVar()
{
  local nm_func="${FUNCNAME[0]}"

  local -i reverse=0
  local dirLIST pathVAR pathLIST dirLIST
  local dir var val tmpSTR chkSTR


  [ $# -lt 1 ] && return 0

  ##########
  # Work on the function arguments
  pathVAR=$( toLOWER "${1-}" | awk '{print $1}' )
  case "${pathVAR}" in
    path)
      var=PATH
      ;;
    ld)
      var=LD_LIBRARY_PATH
      ;;
    man)
      var=MANPATH
      ;;
    matlab)
      var=MATLABPATH
      ;;
    idl)
      ;;
    *)
      echo "Usage: ${nm_func} pathVAR dirLIST"
      echo "       pathVAR one of: path, ld, man, matlab, idl"
      echo "       dirLIST: the list of the directories to include recursively"
      echo "                into the corresponding environment variable"
      echo "       Environment variables that can be set are:"
      echo "         path -> PATH,         ld -> LD_LIBRARY_PATH"
      echo "          man -> MANPATH,  matlab -> MATLABPATH"
      echo "          idl -> IDL_PATH and IDL_DLM_PATH"
      return 1
      ;;
  esac

  if [ $# -lt 2 ]; then
    if [ "X${pathVAR:-}" = "Xidl" ]; then
      IDL_PATH="${IDL_PATH:-}"
      IDL_DLM_PATH="${IDL_DLM_PATH:-}"
      export IDL_PATH IDL_DLM_PATH
    else
      val="$( eval "echo \$$(echo ${var})" )"
      eval "${var}=${val:-}"
      export ${var}
    fi
    return 0
  fi

  dirLIST=$( echo $( for dir in ${2-}; do echo "${dir}"; done | sed 's/\/*$//' ) )
  dirLIST=$( strRmDuplicate "${dirLIST}" )

  # Reverse the order of the input directories (if requested)
  [[ "$( toLOWER "${3-}" | awk '{print $1}' )" = rev* ]] && \
    reverse=1

  if [ ${reverse} -gt 0 ]; then
    tmpSTR=
    dirLIST=$( echo $( for dir in ${dirLIST}; do tmpSTR="${dir} ${tmpSTR}"; done; echo ${tmpSTR}  ) )
  fi
  ##########


  # Were given a directory list therefore, we proceed with the following code


  ##########
  # Special treatment for idl.
  # When idl encounters a '+' sign in front of a directory
  # in the IDL_PATH or IDL_DLM_PATH environment variables
  # it recursively checks the directory for appropriate
  # idl files (*.pro, *.sav, *.dlm) and then expands
  # the environment variables.
  if [ "X${pathVAR:-}" = "Xidl" ]; then
    my_IDL_PATH=${IDL_PATH:-<IDL_DEFAULT>}
    my_IDL_DLM_PATH=${IDL_DLM_PATH:-<IDL_DEFAULT>}

    pathLIST=
    for dir in ${dirLIST}
    do
      if [ -d "${dir}" ]; then
        if [ ${reverse} -gt 0 ]; then
          pathLIST="+${dir}:${pathLIST}"
        else
          pathLIST="${pathLIST}:+${dir}"
        fi
      fi
    done
    # The IDL_PATH variable.
      chkSTR=( $( echo "${my_IDL_PATH}" | sed 's/[+:]/ /g' ) )
      chkSTR=${chkSTR[${#chkSTR[@]}-1]}
    tmpSTR=$( echo ${my_IDL_PATH}${pathLIST:+:+${pathLIST}} | sed 's/[+:]/ /g' )
    tmpSTR=$( strRmDuplicate "${tmpSTR}" )
    tmpSTR=$( echo ${tmpSTR#*${chkSTR}} | sed 's/ /:+/g' )
    if [ ${reverse} -gt 0 ]; then
      my_IDL_PATH=$( echo "+${tmpSTR}:${my_IDL_PATH}" )
    else
      my_IDL_PATH=$( echo ${my_IDL_PATH}:+${tmpSTR} )
    fi
    # The IDL_DLM_PATH variable.
      chkSTR=( $( echo "${my_IDL_DLM_PATH}" | sed 's/[+:]/ /g' ) )
      chkSTR=${chkSTR[${#chkSTR[@]}-1]}
    tmpSTR=$( echo ${my_IDL_DLM_PATH}${pathLIST:+:+${pathLIST}} | sed 's/[+:]/ /g' )
    tmpSTR=$( strRmDuplicate "${tmpSTR}" )
    tmpSTR=$( echo ${tmpSTR#*${chkSTR}} | sed 's/ /:+/g' )
    if [ ${reverse} -gt 0 ]; then
      my_IDL_DLM_PATH=$( echo "+${tmpSTR}:${my_IDL_DLM_PATH}" )
    else
      my_IDL_DLM_PATH=$( echo ${my_IDL_DLM_PATH}:+${tmpSTR} )
    fi

    IDL_PATH=${my_IDL_PATH}
    IDL_DLM_PATH=${my_IDL_DLM_PATH}
    export IDL_PATH IDL_DLM_PATH

    return 0
  fi
  ##########


  ##########
  # Special treatment for matlab.
  # For matlab recurse each input (root) directory
  # and append all directories found in the MATLABPATH
  # environment variable.
  if [ "X${pathVAR:-}" = "Xmatlab" ]; then
    pathLIST="${MATLABPATH:-}"
    for dir in ${dirLIST}
    do
      if [ -d "${dir}" ]; then
        dir=$( find ${dir} \
               -type f \( -iname "*.m" -o -iname "*.mat" -o -iname "*.mex*" \
                                       -o -iname "*.mdl*" -o -iname "*.slx*" \) \
               -exec dirname  {} \; \
               | sort -u | sed '/\/\./d' | tr '\n' ':' | sed 's/:$//' )
        if [ ${reverse} -gt 0 ]; then
          pathLIST="${dir}:${pathLIST}"
        else
          pathLIST="${pathLIST}:${dir}"
        fi
      fi
    done
    pathLIST=$( echo "${pathLIST}" | sed 's/:/ /g' )
    pathLIST=$( strRmDuplicate "${pathLIST}" )
    pathLIST=$( echo "${pathLIST}" | sed 's/ /:/g' )

    MATLABPATH=${pathLIST:-}
    export MATLABPATH

    return 0
  fi
  ##########


  ##########
  # All other PATH variables.
  val="$( eval "echo \$$(echo ${var})" )"
  pathLIST="${val:-}"
  for dir in ${dirLIST}
  do
    if [ -d "${dir}" ]; then
      if [ ${reverse} -gt 0 ]; then
        pathLIST="${dir}:${pathLIST}"
      else
        pathLIST="${pathLIST}:${dir}"
      fi
    fi
  done
  pathLIST=$( echo "${pathLIST}" | sed 's/:/ /g' )
  pathLIST=$( strRmDuplicate "${pathLIST}" )
  pathLIST=$( echo "${pathLIST}" | sed 's/ /:/g' )

  eval "${var}=${pathLIST:-}"
  export ${var}
  ##########


  return 0
}

# -------------------------------------------------------
# checkDIR()
# Usage:      checkDIR [options] dir
# Parameters: dir (string)
# Returns:    1 if the options are not met or, no arguments
#             were supplied or, the dir is an empty string
#             0 in any other case (success)
# Echoes:     NONE
#
# Possible options are:
# -h FILE exists and is a symbolic link (same as -L)
# -L FILE exists and is a symbolic link (same as -h)
# -r FILE exists and is readable
# -x FILE exists and is executable
# -w FILE exists and is writable
#
# Checks if the directory "dir" is a valid directory
# based on the options supplied. If no options supplied
# it simply checks that if "dir" is a directory
# -------------------------------------------------------
checkDIR()
{
  local -i retval=0
  local get_opts my_arg="" chk_my_arg="" my_opts="-d" iopt
# Use these to reset the options since the shell does not
# do that automatically
  local opt_id=${OPTIND} opt_arg="${OPTARG}"

  [ $# -eq 0 ] && { retval=1; return ${retval}; }

  while getopts ":hLrxw" get_opts
  do
    case ${get_opts} in
      h|L) my_opts="${my_opts} -h";;
        r) my_opts="${my_opts} -r";;
        x) my_opts="${my_opts} -x";;
        w) my_opts="${my_opts} -w";;
        *) ;; # DEFAULT
    esac
  done

# Get the first argument after the options
  shift $(( ${OPTIND} - 1))
  my_arg=${1}

# Reset the option variables since the shell doesn't do it
  OPTIND=${opt_id}
  OPTARG="${opt_arg}"

  chk_my_arg="$( echo "${my_arg##*/}" | sed -e 's/[[:space:]]//g' )"
  [ "X${my_arg}" = "X" ] && { retval=1; return ${retval}; }

  for iopt in ${my_opts}
  do
    [ ! ${iopt} "${my_arg}" ] && { retval=1; return ${retval}; }
  done

  return ${retval}
}

# -------------------------------------------------------
# checkPROG()
# Usage:      checkPROG [options] program
# Parameters: program (string)
# Returns:    1 if the options are not met or, no arguments
#             were supplied or, the program is an empty string
#             0 in any other case (success)
# Echoes:     NONE
#
# Possible options are:
# -h FILE exists and is a symbolic link (same as -L)
# -L FILE exists and is a symbolic link (same as -h)
# -r FILE exists and is readable
# -s FILE exists and has a size greater than zero
#
# Checks if the program "program" is a valid executable
# program based on the options supplied. If no options
# supplied it simply checks that if "program" is an
# executable program
# -------------------------------------------------------
checkPROG()
{
  local get_opts my_arg="" chk_my_arg="" my_opts="-f -x" iopt
# Use these to reset the options since the shell does not
# do that automatically
  local opt_id=${OPTIND} opt_arg="${OPTARG}"

  [ $# -eq 0 ] && return 1

  while getopts ":hLrs" get_opts
  do
    case ${get_opts} in
      h|L) my_opts="${my_opts} -h";;
        r) my_opts="${my_opts} -r";;
        s) my_opts="${my_opts} -s";;
        *) ;; # DEFAULT
    esac
  done

# Get the first argument after the options
  shift $(( ${OPTIND} - 1))
  my_arg=${1}

# Reset the option variables since the shell doesn't do it
  OPTIND=${opt_id}
  OPTARG="${opt_arg}"

  chk_my_arg="$( echo "${my_arg##*/}" | sed -e 's/[[:space:]]//g' )"
  [ "X${chk_my_arg}" = "X" ] && return 1

  for iopt in ${my_opts}
  do
    [ ! ${iopt} ${my_arg} ] && return 1
  done

  return 0
}

# -------------------------------------------------------
# getPROG()
# Usage:      getPROG program
#
# Parameters:
# program : The name of the program (STRING).
#
# Returns : 0 (success), 1 (failure)
# Exports : NONE
# Echoes  : The program name or an error message on failure
#
# Checks if the program "program" is a valid executable
# program. On error, echoes an error message and returns 1
# -------------------------------------------------------
getPROG()
{
  local nm_func=${FUNCNAME[0]}

  local nm_prog exe_prog old_PATH
  local dirLIST my_dirLIST
  local dir dir1
  local -i STATUS

  local cwd="$( pwd )"
  local old_PATH=${PATH}


  if [ $# -eq 0 ]; then
    exe_prog="Usage: ${nm_func} progname"
    echo -n "${exe_prog}"
    return 1
  fi


  nm_prog=${1}
  unalias ${nm_prog} >/dev/null 2>&1


  ###############
  ### Check if full program path was supplied
  #   (including the current directory full path)
  if $( checkPROG "${nm_prog}" ); then
    exe_prog="$( pathFILE "${nm_prog}" )"
    echo -n ${exe_prog}
    return 0
  fi


  ###############
  ### Check if program is a bultin function
  unset PATH
    exe_prog="$( command -v ${nm_prog} 2>&1 )"
    STATUS=$?
  PATH=${old_PATH}
  export PATH
  if [ ${STATUS} -eq 0 ]; then
    echo -n "${exe_prog}"
    return ${STATUS}
  fi


  ###############
  ### Check if program is in bin Bin sbin ... ${HOME}/bin ${HOME}/Bin ${HOME}/sbin ...
  #   and in user's path.
  dirLIST="bin Bin sbin ${cwd} ${cwd}/.. ${cwd}/../.."
  dirLIST="${dirLIST} ${cwd}/../../.. ${cwd}/../../../.. ${cwd}/../../../../.."
  dirLIST="${dirLIST} ${RootDir:-} ${ROOT_DIR:-} ${CAST_ROOT:-}"
  dirLIST="${dirLIST} ${MY_PROJECT_DIR:-} ${PROJECT_DIR:-} ${HOME:-}"
  my_dirLIST=
  for dir in ${dirLIST}
  do
    if $( checkDIR -rx "${dir}" ); then
      pushd ${dir} >/dev/null 2>&1
        dir="$( pwd )"
      popd >/dev/null 2>&1

      dir="${dir#${cwd}/}"
      if [ -n "${dir:+1}" ]; then
        my_dirLIST="${my_dirLIST} ${dir}"
        for idir in Bin bin sbin
        do
          dir1="$( echo "${dir}" | sed 's/\/*$//' )"
          [ -d ${dir1}/${idir} ] && \
            my_dirLIST="${my_dirLIST} ${dir1}/${idir}"
        done
      fi
    fi
  done
  dirLIST=$( strRmDuplicate "${my_dirLIST}" )
  dirLIST=$( strTrim "${dirLIST}" 2 )

  GetPathEnvVar path "${dirLIST}" reverse
  
  exe_prog="$( command -v ${nm_prog} 2>&1 )"
  STATUS=$?

  [ ${STATUS} -ne 0 ] && \
    exe_prog="${nm_func}: Could not locate/execute the program/function \"${nm_prog:-UNDEF}\""

  PATH=${old_PATH}
  export PATH

  echo -n "${exe_prog}"

  return ${STATUS}
}

# -------------------------------------------------------
# getDirList()
# Usage:      getDirList inp_dirs
# Parameters:
#   inp_dirs    : the list of sub-directories to list in, STRING
#                 default="."
# Returns :   the status of search, 0 = success
# Echoes  :   none
# Exports :   the full path of the directories in the list, STRING
#
# getDirList lists all directories(s) found in the supplied list
#            and in the directories defined in the environment variables
#            DATA_DIR, INP_DIR, FRC_DIR, OUT_DIR removing the duplicates.
#            The directories should exist and be readable by the current user.
# -------------------------------------------------------
getDirList()
{
  local nm_func="${FUNCNAME[0]}"

  local inpLIST dirLIST my_dirLIST dir inp
  local my_dir1 my_dir2 my_dir3 my_dir4
  local my_dir5 my_dir6 my_dir7 my_dir8
  local my_dir9

  local cwd="$( pwd )"

  inpLIST="${*}"

  # Root directories
  my_dir1="${DATA_DIR:-${cwd:-.}}"
  my_dir2="${INP_DIR:-${cwd:-.}}"
  my_dir3="${FRC_DIR:-${cwd:-.}}"
  my_dir4="${OUT_DIR:-${cwd:-.}}"
  my_dir9="${cwd:-.}"
  my_dirLIST="${my_dir1} ${my_dir2} ${my_dir3} ${my_dir4} \
              ${my_dir5} ${my_dir6} ${my_dir7} ${my_dir8} \
              ${my_dir9}"
  my_dirLIST="$( strRmDuplicate "${my_dirLIST}" )"

  dirLIST=
  for inp in ${inpLIST}
  do
    inp="$( echo "${inp}" | sed 's/\/*$//' )"
    dirLIST="${dirLIST} ${inp}"
    for dir in ${my_dirLIST}
    do
      dir="$( echo "${dir}" | sed 's/\/*$//' )"
      dirLIST="${dirLIST} ${dir}/${inp} ${dir}"
    done
  done
  dirLIST="$( strRmDuplicate "${dirLIST}" )"

  my_dirLIST=
  for dir in ${dirLIST}
  do
    if $( checkDIR -rx "${dir}" ); then
      pushd ${dir} >/dev/null 2>&1
        dir="$( pwd )"
      popd >/dev/null 2>&1

      dir="${dir#${cwd}/}"
      [ -n "${dir:+1}" ] && my_dirLIST="${my_dirLIST} ${dir}"
    fi
  done
  dirLIST="$( strRmDuplicate "${my_dirLIST}" )"
  dirLIST="$( strTrim "${dirLIST}" 2 )"

  echo -n ${dirLIST:-${cwd:-.}}
  
  return 0
}

# -------------------------------------------------------
# makeDIR()
# Usage:      makeDIR FunctionName DirName
# Parameters: FunctionName (string), the name of the calling function (optional)
# Parameters: DirName (string), the directory to create
# Returns:    1 on failure (eg., argument list is empty)
#             0 on success
# Echoes:     NONE
#
# Creates the directory "DirName" if it doesn't exist,
# if the directory exists it checks if it is readable.
# On failure this function issues: exit 1
# -------------------------------------------------------
makeDIR()
{
  local my_dir

  [ $# -eq 0 ] && return 0

  my_dir="$( strTrim "${1}" 2 )"
  [ -z "${my_dir:-}" ] && return 0

  if ! $( checkDIR "${my_dir}" ); then
    mkdir -p "${my_dir}" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
      procError "failed to create the directory: ${my_dir:-UNDEF}"
    else
      procWarn "created the empty directory: ${my_dir:-UNDEF}"
    fi
  fi

  if ! $( checkDIR -rwx "${my_dir}" ); then
    procError "directory exists but read/write/execute permissions are not valid" \
              "  Directory = ${my_dir:-UNDEF}"
  fi

  return 0
}

# -------------------------------------------------------
# deleteDIR()
# Usage:      deleteDIR DirName
# Parameters: DirName (string), the directory to delete
# Returns:    1 on failure (eg., argument list is empty)
#             0 on success
# Echoes:     NONE
#
# Deletes the directory "DirName" if it exists,
# if the directory exists it checks if it is readable.
# On failure this function issues: exit 1
# -------------------------------------------------------
deleteDIR()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0
  local my_dir
  local not_dirs=":/:${HOME}:${PATH}:.:"

  [ $# -eq 0 ] && { retval=1; return ${retval}; }

  my_dir="${1}"

  [[ :${not_dirs}: == *:${my_dir}:* ]] && { retval=1; return ${retval}; }
  
  [ $(id -u) -eq 0 ] && { retval=1; return ${retval}; }

  if $( checkDIR "${my_dir}" ); then
    rm -rf "${my_dir}" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
      procError "failed to delete the directory: ${my_dir:-UNDEF}"
    else
      procWarn "deleted the directory: ${my_dir:-UNDEF}"
    fi
  fi

  return ${retval}
}

MakeDeleteDirs()
{
  local nm_func="${FUNCNAME[0]}"

  local mydirs= idir=

  if [ $# -lt 1 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} \"dirs\""
  fi

  mydirs="${1}"
  for idir in ${mydirs}
  do
    deleteDIR "${idir}"
    makeDIR "${idir}"
  done

  return 0
}

# -------------------------------------------------------
# searchFILE()
# Usage:      searchFILE inp_fname inp_dirs
# Parameters:
#   inp_fname   : the list of input file expressions to search for, STRING
#   inp_dirs    : the list of directories to search in, STRING
#                 default="."
# Returns :   the status of search, 0 = success
# Echoes  :   none
# Exports :   the full path of the file(s) found or empty string, STRING
#
# searchFILE searches for all file(s) with the supplied filename expressions
# in the list of supplied directories. The files should be readable by the
# current user.
# -------------------------------------------------------
searchFILE()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=1
  local exprLIST dirLIST idir iexpr
  local tmpLIST tmpNAMES ifile

  unset foundFilePath

  if [ $# -lt 1 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename_expr [dirs to search]"
  fi

  exprLIST="${1}"
  dirLIST="${2:-.}"

  for idir in ${dirLIST}
  do
    if $( checkDIR "${idir}" ); then
      tmpLIST=
      for iexpr in ${exprLIST}
      do
        tmpLIST="${tmpLIST} $( ls "${idir}" 2>/dev/null | egrep "^${iexpr}$" )"
      done

      if [ -n "${tmpLIST:+1}" ]; then
        tmpLIST="$( strRmDuplicate "${tmpLIST}" )"

        for ifile in ${tmpLIST}
        do
          ifile="${idir}/${ifile}"
          checkFILE -r "${ifile}"
          [ $? -eq 0 ] && tmpNAMES="${tmpNAMES} ${ifile}"
        done
      fi
    fi
  done

  export foundFilePath="$( strTrim "${tmpNAMES}" 2 )"
  [ -n "${foundFilePath:+1}" ] && retval=0
  
  return ${retval}
}

# -------------------------------------------------------
# pathFILE()
# Usage:      pathFILE inp_file
# Parameters:
#   inp_file : the name of the file to determine its abosule path
#
# Returns :   none
# Echoes  :   the full path of the file
# Exports :   none
#
# pathFILE determines the full path to a file
# -------------------------------------------------------
pathFILE()
{
  local nm_func="${FUNCNAME[0]}"

  local inp_file inp_dir

  if [ $# -lt 1 ]; then
    inp_file="wrong number of arguments
              usage: ${nm_func} filename"
    echo -n "${inp_file}"
    return 1
  fi

  inp_file=${1}

  inp_dir=$( dirname "${inp_file}" )
  inp_file=$( basename "${inp_file}" )

  if [ -d "${inp_dir}"  ]; then
    pushd ${inp_dir} >/dev/null 2>&1
      inp_dir="$( pwd )"
    popd >/dev/null 2>&1
  fi

  if [ "${inp_dir}" = "/" ] && [ "${inp_file}" = "/" ]; then
    inp_file=${inp_dir}
  elif [ "${inp_dir}" = "/" ]; then
    inp_file=${inp_dir}${inp_file}
  else
    inp_file=${inp_dir}/${inp_file}
  fi

  echo -n ${inp_file}

  return 0
}

# -------------------------------------------------------
# linkFILE()
# Usage:      linkFILE file1 file2
# Parameters:
#   file1   : the name of the file/directory to link against
#   file2   : the name of the link
#
# Returns :   0 (success), or >0 (failure)
# Echoes  :   none
# Exports :   none
#
# linkFILE makes a link to a file/directory
# -------------------------------------------------------
linkFILE()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0
  local file1 file2
  local f1 f2 d1 d2

  if [ $# -lt 2 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename1 filename2"
  fi

  file1="$( pathFILE "${1}" )"
  file2="$( pathFILE "${2}" )"

  if ! $( checkFILE -r "${file1}" ) && ! $( checkDIR -rx "${file1}" ); then
    procError "The source file does not exist or," \
              "permissions are not valid for the current user." \
              "  File = ${file1}" \
              "  Link = ${file2}" \
              "The link to the source file won't be created."
  fi

  [ "X${file1}" = "X${file2}" ] && return 0

  if $( checkFILE "${file2}" ) || $( checkDIR "${file2}" ); then
    rm -rf "${file2}" >/dev/null 2>&1
    if [ $? -ne 0 ]; then
      procError "Couldn't remove the old link file." \
                "  File = ${file1}" \
                "  Link = ${file2}" \
                "The link to the source file won't be created."
    fi
  fi

  d1="$( dirname  "${file1}" )"
  f1="$( basename "${file1}" )"
  d2="$( dirname  "${file2}" )"
  f2="$( basename "${file2}" )"
  
  if [ "${d1}" = "${d2}" ]; then
    pushd "${d1}" >/dev/null 2>&1
      ln -sf ${f1} ${f2} >/dev/null 2>&1
      retval=$?
    popd >/dev/null 2>&1
  else
    ln -sf ${file1} ${file2} >/dev/null 2>&1
    retval=$?
  fi

  return ${retval}
}
############################################################


############################################################
##### GENERAL MODEL FUNCTIONS
############################################################
# -------------------------------------------------------
# getDomString()
# Usage:      getDomString dom_number
# Parameters: dom_number
#             dom_number: the domain number (integer >0)
#
# Returns:    0 if a valid domain number supplied (success)
#             1 in any other case (error)
# Exports:    NONE
# Echoes:     dom_string=_dXX, or dom_string=
#
# Constructs the domain string given a domain number.
# -------------------------------------------------------
getDomString()
{
  local -i STATUS=1
  local dom_str

  if [ "${1:-UNDEF}" -eq "${1}" ] 2>/dev/null
  then
    [ ${1} -gt 0 ] && \
      [ ${1} -lt 100 ] && \
        dom_str=_d$( printf "%0*d" 2 ${1} )
    STATUS=$?
  fi

  echo -n ${dom_str}

  return ${STATUS}
}

# -------------------------------------------------------
# getModDataFile()
# Usage:      getModDataFile f{name/expr} search_dirs
# Parameters: fname or fexpr, search_dirs, BegDate
#             fname: the filename to search for (mandatory) OR
#             fexpr: the list of filename regular expressions
#                    to search for (mandatory)
#             search_dirs: the list of directories to search
#                          for the above files (mandatory)
# Returns:    0 if a valid file found (success)
#             1 in any other case (error)
# Exports:    foundFilePath
# Echoes:     NONE
#
# Find the file that meets the user's criteria.
# -------------------------------------------------------
getModDataFile()
{
  local nargs
  local fexpr fdirs
  local c_file
  local -i retval=1

  unset foundFilePath

  nargs=$#
  fexpr="$( strTrim "${1}" 2 )"
  fdirs="$( strTrim "${2}" 2 )"

  if [ -z "${fexpr:-}" -o -z "${fdirs:-}" ]; then
    procError "invalid files/file expressions or search directories were supplied:" \
              "  Files(s): ${fexpr:-UNDEF}" \
              "      Dirs: ${fdirs:-UNDEF}"
  fi
  
  case 1 in
    $(( ${nargs} >= 2 )) )
      searchFILE "${fexpr}" "${fdirs}"
      c_file="$( echo ${foundFilePath} | awk '{print $1}' )"
      unset foundFilePath

      if [ -z "${c_file:-}" ]; then
        procError "no valid files found" \
                  "  Checked for files(s): ${fexpr}" \
                  "       Checked in dirs: ${fdirs}"
      fi

      retval=0
    ;;
    *)
      procError "wrong number of arguments" \
                "usage: ${nm_func} \"fname_expr\" \"dirs_to_search\""
    ;;
  esac

  export foundFilePath="$( pathFILE "${c_file}" )"

  return ${retval}
}

getOceanModels()
{
  local nm_func="${FUNCNAME[0]}"

  local def_models="ROMS HYCOM"

  local i imod ans
  local models mod_mods suse_mods val_mods

  SUPPORTED_OCEAN_MODELS=$( toUPPER "${SUPPORTED_OCEAN_MODELS} ${def_models}" )
  SUPPORTED_OCEAN_MODELS=$( strRmDuplicate "${SUPPORTED_OCEAN_MODELS}" )
  export SUPPORTED_OCEAN_MODELS

  unset ocnMODELS ocnUSEMODS ocnUSEVALS

  # The environment variables USE_* should be already set before calling this function.
  for imod in ${SUPPORTED_OCEAN_MODELS}
  do
    ans="$( eval "echo \$$(echo USE_${imod})" )"
    ans="$( getYesNo "${ans:-no}" )"

    ocnMODELS="${ocnMODELS} ${imod}"
    ocnUSEMODS="${ocnUSEMODS} USE_${imod}"
    ocnUSEVALS="${ocnUSEVALS} ${ans}"
  done

  export ocnMODELS ocnUSEMODS ocnUSEVALS

  return 0
}

checkOceanModels()
{
  local nm_func="${FUNCNAME[0]}"

  local -i modFLG=0
  local i imod ans
  local models use_mods val_mods

  # The environment variables USE_* should be already set before calling this function.
  getOceanModels
    models=( ${ocnMODELS} )
  use_mods=( ${ocnUSEMODS} )
  val_mods=( ${ocnUSEVALS} )

  for ((i = 0; i < ${#models[@]}; i++))
  do
    imod=${use_mods[${i}]}
    adjustYESNOVar ${imod}

    ans="$( eval "echo \$$(echo ${imod})" )"
    
    [ -n "${ans:+1}" ] && modFLG=$(( ${modFLG} + 1 ))
  done
  
  if [ ${modFLG} -gt 1 ]; then
    procError "Only one ocean model can be used at a time"  \
              "Please adjust your environment accordingly"  \
              "  ${use_mods[0]:+${use_mods[0]} = }${val_mods[0]}" \
              "  ${use_mods[1]:+${use_mods[1]} = }${val_mods[1]}" \
              "  ${use_mods[2]:+${use_mods[2]} = }${val_mods[2]}" \
              "  ${use_mods[3]:+${use_mods[3]} = }${val_mods[3]}" \
              "  ${use_mods[4]:+${use_mods[4]} = }${val_mods[4]}"
  fi

  return 0
}

setOceanModels()
{
  local nm_func="${FUNCNAME[0]}"

  local i imod ans
  local models use_mods val_mods

  getOceanModels
    models=( ${ocnMODELS} )
  use_mods=( ${ocnUSEMODS} )
  val_mods=( ${ocnUSEVALS} )

  for ((i = 0; i < ${#models[@]}; i++))
  do
    ans="$( getYesNo "${val_mods[${i}]}" )"
    imod="${use_mods[${i}]}"
    
    export ${imod}="${ans}"
    [ "${ans:-no}" = "no" ] && unset ${imod}
  done

  return 0
}

OceanModelName()
{
  local nm_func="${FUNCNAME[0]}"

  local model

  model=$( strTrim "${OCEAN_MODEL_NAME:-}" 2 )
  model=( $( toUPPER "${OCEAN_MODEL_NAME}" ) )

  #model="${model[0]:-ROMS}" # Default is ROMS
  model="${model[0]:-}" # Default is NONE

  export OCEAN_MODEL_NAME="${model}"

  return 0
}

Adjust_ModelEnvVars()
{
  local nm_func=${FUNCNAME[0]}

  local file="${1:-models_env}"
  local var_arr var ans
  local i ivar

  if $( checkFILE -r "${file}" ); then
    var_arr=( $( cat "${file}" | sed '/^[#\!]/d' | sed '/^$/d' ) )

    for ((i = 0; i < ${#var_arr[@]}; i++))
    do
      ivar=( $( echo ${var_arr[${i}]} | sed 's/=/ /g' ) )

      var="${ivar[0]}"
      ans="$( getYesNo "${ivar[1]}" )"

      export ${var}="${ans}"
      [ "${ans:-no}" = "no" ] && unset ${var}
    done
  fi

  ##### Just in case reset the next variables
  setOceanModels

  adjustYESNOVar COUPLED_SYSTEM USE_MPI USE_OpenMP
  adjustYESNOVar USE_ROMS USE_HYCOM USE_WRF USE_SWAN
  adjustYESNOVar USE_SED USE_ICE

  return 0
}

NumberOfActiveModels()
{
  local nm_func=${FUNCNAME[0]}

  local -i modFLG=0

  local i imod ans
  local models use_mods val_mods

  # Get all supported ocean models.
  getOceanModels
    models=( ${ocnMODELS} )
  use_mods=( ${ocnUSEMODS} )
  val_mods=( ${ocnUSEVALS} )

  # Get all possible models and calculate the number of models in use.
  adjustYESNOVar USE_WRF USE_SWAN
  [ -n "${USE_WRF:+1}"  ] && modFLG=$(( ${modFLG} + 1 ))
  [ -n "${USE_SWAN:+1}" ] && modFLG=$(( ${modFLG} + 1 ))
  
  # Supported ocean models.
  for ((i = 0; i < ${#models[@]}; i++))
  do
    imod=${use_mods[${i}]}
    adjustYESNOVar ${imod}

    ans="$( eval "echo \$$(echo ${imod})" )"

    [ -n "${ans:+1}" ] && modFLG=$(( ${modFLG} + 1 ))
  done

  echo -n ${modFLG}

  return 0
}
############################################################


############################################################
##### DATE FUNCTIONS
############################################################
getDate()
{
  local nm_func="${FUNCNAME[0]}"

  local opt_all opt_opt opt_arg
  local out_date my_DATE my_FMT my_TZ=UTC
  local status=0


  # -----
  # Process the function options
  opt_all=( date fmt tz )
  opt_all=":$( echo "${opt_all[@]/#/-} ${opt_all[@]/#/--}" | sed 's/ /:/g' ):"

  __OPTION_LIST=
  while test $# -gt 0; do
    case "${1}" in
      -[^-]*=* | --[^-]*=* )
        opt_opt="$( toLOWER "$( echo "${1}" | sed 's/=.*//' )" )"
        opt_arg="$( strTrim "$( echo "${1}" | sed 's/.*=//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      -[^-]* | --[^-]* )
        opt_opt="$( toLOWER "${1}" )"
        opt_arg="$( strTrim "$( echo "${2}" | sed 's/=.*//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      *)
        opt_opt= 
        opt_arg=
        ;;
    esac

    case "${opt_opt}" in
      -date | --date )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            my_DATE="${opt_arg}"
          fi
        ;;
      -fmt | --fmt )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            my_FMT="${opt_arg}"
            my_FMT="$(echo "${my_FMT}" | sed 's/^[[:space:]]*//')"
            [ "${my_FMT:0:1}" != "+" ] && my_FMT="+${my_FMT}"
          fi
        ;;
      -tz | --tz )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            my_TZ="${opt_arg}"
          fi
        ;;
      *) ;; # DEFAULT
    esac
    shift
    opt_opt= 
    opt_arg=
  done
  __OPTION_LIST=
  # -----


  my_DATE="$( echo "${my_DATE}" | sed 's/_/ /g' )"

  out_date=( $( echo "${my_DATE}" | sed 's/[-_/[:space:].:]/ /g' ) )
  if [ ${#out_date[@]} -lt 3 ]; then
    out_date="${nm_func}: invalid date \`${my_DATE:-UNDEF}'"
    echo -n "${out_date}"
    return 1
  fi

  unset out_date
  export TZ="${my_TZ}"
    if [ -n "${my_FMT:+1}" ]; then
      out_date="$( date -d "${my_DATE:-UNDEF}" "${my_FMT}" 2>&1 )"
      status=$?
    else
      out_date="$( date -d "${my_DATE:-UNDEF}" 2>&1 )"
      status=$?
    fi
  unset TZ

  echo -n ${out_date}
  
  return ${status}
}

# -------------------------------------------------------
# getDateExpr()
# Usage:      getDateExpr date_format YEAR MONTH DAY HOUR
# Parameters: date_format
#               one of the strings: YMDH YMD YM Y MDYH MDY MY DMYH DMY YJH YJ JY
#             YEAR MONTH DAY HOUR (in this sequence)
# Examples:   getDateExpr YMDH YEAR MONTH DAY HOUR
#             getDateExpr YMDH YEAR MONTH DAY [HOUR]
#             getDateExpr DMYH YEAR MONTH DAY HOUR
#             getDateExpr YJH  YEAR MONTH DAY HOUR
#             If hour is not supplied it is neglected from
#             the regular expression
# Returns:    0 (upon success), otherwise an error code
# Echoes:     The regular expression for the date string
# -------------------------------------------------------
getDateExpr()
{
  local nm_func="${FUNCNAME[0]}"
  local date date_format dfmt ofmt
  local yr=-1 mo=-1 da=-1 yd=-1 hr=-1 mn=0 sc=0
  local expr="[.:_-]"

  if [ $# -lt 1 ]; then
    ofmt="Need to supply a date format
            usage: ${nm_func} date_format [YEAR, MONTH, DAY[, HOUR]]
            date format one of: YMDH YMD YM Y MDYH MDY MY DMYH DMY YJH YJ JY"
    echo -n "${ofmt}"
    return 1
  fi

  date_format="${1}"
  dfmt=$( toUPPER "${date_format}" )

  case "${dfmt}" in
    YMDH)
        if [ $# -lt 5 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY HOUR"
          return 1
        fi

        date="${2}-${3}-${4} ${5}:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${yr}${expr}?${mo}${expr}?${da}"
        ofmt="${ofmt}${expr}?${hr}(${expr}?${mn}${expr}?${sc})?"
      ;;
     YMD)
        if [ $# -lt 4 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY"
          return 1
        fi

        date="${2}-${3}-${4} 00:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${yr}${expr}?${mo}${expr}?${da}"
      ;;
     YM)
        if [ $# -lt 3 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH"
          return 1
        fi

        date="${2}-${3}-01 00:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${yr}${expr}?${mo}"
      ;;
     Y)
        if [ $# -lt 2 ]; then
          echo -n "usage: ${nm_func} date_format YEAR"
          return 1
        fi

        date="${2}-01-01 00:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${yr}"
      ;;
    MDYH)
        if [ $# -lt 5 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY HOUR"
          return 1
        fi

        date="${2}-${3}-${4} ${5}:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${mo}${expr}?${da}${expr}?${yr}"
        ofmt="${ofmt}${expr}?${hr}(${expr}?${mn}${expr}?${sc})?"
      ;;
     MDY)
        if [ $# -lt 4 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY"
          return 1
        fi

        date="${2}-${3}-${4} 00:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${mo}${expr}?${da}${expr}?${yr}"
      ;;
     MY)
        if [ $# -lt 3 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH"
          return 1
        fi

        date="${2}-${3}-01 00:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${mo}${expr}?${yr}"
      ;;
    DMYH)
        if [ $# -lt 5 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY HOUR"
          return 1
        fi

        date="${2}-${3}-${4} ${5}:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${da}${expr}?${mo}${expr}?${yr}"
        ofmt="${ofmt}${expr}?${hr}(${expr}?${mn}${expr}?${sc})?"
      ;;
     DMY)
        if [ $# -lt 4 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY"
          return 1
        fi

        date="${2}-${3}-${4} 00:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        ofmt="${expr}?${da}${expr}?${mo}${expr}?${yr}"
      ;;
     YJH)
        if [ $# -lt 5 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY HOUR"
          return 1
        fi

        date="${2}-${3}-${4} ${5}:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        yd=$( getDate --date="${yr}-${mo}-${da} 00:00:00" --fmt="%j" )
        ofmt="${expr}?${yr}${expr}?${yd}"
        ofmt="${ofmt}${expr}?${hr}(${expr}?${mn}${expr}?${sc})?"
      ;;
      YJ)
        if [ $# -lt 4 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY"
          return 1
        fi

        date="${2}-${3}-${4} 00:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        yd=$( getDate --date="${yr}-${mo}-${da} 00:00:00" --fmt="%j" )
        ofmt="${expr}?${yr}${expr}?${yd}"
      ;;
      JY)
        if [ $# -lt 4 ]; then
          echo -n "usage: ${nm_func} date_format YEAR MONTH DAY"
          return 1
        fi

        date="${2}-${3}-${4} 00:00:00"
        date="$( getDate --date="${date}" --fmt='+%Y %m %d %H %M %S' )"
        if [ $? -ne 0 ]; then
          echo -n "${date}"
          return 1
        fi

        date=( ${date} )
        yr=${date[0]}
        mo=${date[1]}
        da=${date[2]}
        hr=${date[3]}
        mn=${date[4]}
        sc=${date[5]}
        yd=$( getDate --date="${yr}-${mo}-${da} 00:00:00" --fmt="%j" )
        ofmt="${expr}?${yd}${expr}?${yr}"
      ;;
    *)
        ofmt="Invalid date format: ${date_format}
                usage: ${nm_func} date_format [YEAR, MONTH, DAY[, HOUR]]
                date format one of: YMDH YMD YM Y MDYH MDY MY DMYH DMY YJH YJ JY"
        echo -n "${ofmt}"
        return 1
      ;; # DEFAULT
  esac

  echo -n ${ofmt}

  return 0
}

# -------------------------------------------------------
# getDateStrExpr()
# Usage:      getDateStrExpr date_format
# Parameters: date_format
#               one of the strings: YMDH YMD YM Y MDYH MDY MY DMYH DMY YJH YJ JY
# Examples:   getDateStrExpr YMDH
#             getDateStrExpr DMYH
#             getDateStrExpr YJH 
# Returns:    0 (upon success), otherwise an error code
# Echoes:     The regular expression for the date string
# -------------------------------------------------------
getDateStrExpr()
{
  local nm_func="${FUNCNAME[0]}"

  local date_format dfmt ofmt
  local yr mo da yd hr mn sc
  local dgt2 dgt3 dgt4 expr

  if [ $# -lt 1 ]; then
    ofmt="Need to supply a date format
            usage: ${nm_func} date_format
            date format one of: YMDH YMD YM Y MDYH MDY MY DMYH DMY YJH YJ JY"
    echo -n "${ofmt}"
    return 1
  fi

  expr="[.:_-]"
  dgt4="[0-9][0-9][0-9][0-9]"
  dgt3="[0-9][0-9][0-9]"
  dgt2="[0-9][0-9]"

  date_format="${1}"
  dfmt=$( toUPPER "${date_format}" )

  case "${dfmt}" in
    YMDH)
        yr="${dgt4}"
        mo="${dgt2}"
        da="${dgt2}"
        hr="${dgt2}"
        mn=
        sc=
        ofmt="${yr:+${expr}?${yr}}${mo:+${expr}?${mo}}"
        ofmt="${ofmt}${da:+${expr}?${da}}${hr:+${expr}?${hr}}"
      ;;
     YMD)
        yr="${dgt4}"
        mo="${dgt2}"
        da="${dgt2}"
        hr=
        mn=
        sc=
        ofmt="${yr:+${expr}?${yr}}${mo:+${expr}?${mo}}"
        ofmt="${ofmt}${da:+${expr}?${da}}${hr:+${expr}?${hr}}"
      ;;
     YM)
        yr="${dgt4}"
        mo="${dgt2}"
        da=
        hr=
        mn=
        sc=
        ofmt="${yr:+${expr}?${yr}}${mo:+${expr}?${mo}}"
        ofmt="${ofmt}${da:+${expr}?${da}}${hr:+${expr}?${hr}}"
      ;;
     Y)
        yr="${dgt4}"
        mo=
        da=
        hr=
        mn=
        sc=
        ofmt="${yr:+${expr}?${yr}}${mo:+${expr}?${mo}}"
        ofmt="${ofmt}${da:+${expr}?${da}}${hr:+${expr}?${hr}}"
      ;;
    MDYH)
        yr="${dgt4}"
        mo="${dgt2}"
        da="${dgt2}"
        hr="${dgt2}"
        mn=
        sc=
        ofmt="${mo:+${expr}?${mo}}${da:+${expr}?${da}}"
        ofmt="${ofmt}${yr:+${expr}?${yr}}${hr:+${expr}?${hr}}"
      ;;
     MDY)
        yr="${dgt4}"
        mo="${dgt2}"
        da="${dgt2}"
        hr=
        mn=
        sc=
        ofmt="${mo:+${expr}?${mo}}${da:+${expr}?${da}}"
        ofmt="${ofmt}${yr:+${expr}?${yr}}${hr:+${expr}?${hr}}"
      ;;
     MY)
        yr="${dgt4}"
        mo="${dgt2}"
        da=
        hr=
        mn=
        sc=
        ofmt="${mo:+${expr}?${mo}}${da:+${expr}?${da}}"
        ofmt="${ofmt}${yr:+${expr}?${yr}}${hr:+${expr}?${hr}}"
      ;;
    DMYH)
        yr="${dgt4}"
        mo="${dgt2}"
        da="${dgt2}"
        hr="${dgt2}"
        mn=
        sc=
        ofmt="${da:+${expr}?${da}}${mo:+${expr}?${mo}}"
        ofmt="${ofmt}${yr:+${expr}?${yr}}${hr:+${expr}?${hr}}"
      ;;
     DMY)
        yr="${dgt4}"
        mo="${dgt2}"
        da="${dgt2}"
        hr=
        mn=
        sc=
        ofmt="${da:+${expr}?${da}}${mo:+${expr}?${mo}}"
        ofmt="${ofmt}${yr:+${expr}?${yr}}${hr:+${expr}?${hr}}"
      ;;
     YJH)
        yr="${dgt4}"
        mo=
        da="${dgt3}"
        hr="${dgt2}"
        mn=
        sc=
        ofmt="${yr:+${expr}?${yr}}${da:+${expr}?${da}}"
        ofmt="${ofmt}${hr:+${expr}?${hr}}"
      ;;
      YJ)
        yr="${dgt4}"
        mo=
        da="${dgt3}"
        hr=
        mn=
        sc=
        ofmt="${yr:+${expr}?${yr}}${da:+${expr}?${da}}"
        ofmt="${ofmt}${hr:+${expr}?${hr}}"
      ;;
      JY)
        yr="${dgt4}"
        mo=
        da="${dgt3}"
        hr=
        mn=
        sc=
        ofmt="${da:+${expr}?${da}}${yr:+${expr}?${yr}}"
        ofmt="${ofmt}${hr:+${expr}?${hr}}"
      ;;
    *)
        ofmt="Invalid date format: ${date_format}
                usage: ${nm_func} date_format
                date format one of: YMDH YMD YM Y MDYH MDY MY DMYH DMY YJH YJ JY"
        echo -n "${ofmt}"
        return 1
      ;; # DEFAULT
  esac

  echo -n ${ofmt}

  return 0
}

# -------------------------------------------------------
# getInpTimeStamp()
# Usage:      getInpTimeStamp "date string"
# Parameters: date, accepted date string formats:
#               YYYY_SEP_MO_SEP_DA HR_SEP_MN_SEP_SC [ZONE]
#               where _SEP_ can be one of -,/,_,.,:,white space
# Returns:    NONE
# Echoes:     NONE
# -------------------------------------------------------
getInpTimeStamp()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0 jul0=-1
  local thisDATE

  if [ $# -lt 1 ]; then
    procError "need to define a date" \
              "usage: ${nm_func} date"
  fi

  unset myYR myMO myDA myHR myMN mySC myJUL
  unset myYRStr myMOStr myDAStr myHRStr myMNStr mySCStr myDATE


  thisDATE=$( getDate --date="${REF_DATE:-UNDEF}" --fmt='+%s' )
  if [ $? -ne 0 ]; then
    procError "User supplied wrong reference date (format?, undefined?):" \
              "  REF_DATE = ${REF_DATE:-UNDEF}" \
              "Please modify the script and define the environment variable REF_DATE" \
              "following date's command format guidelines."
  fi


  thisDATE="$( echo "${1}" | sed 's/[-_/[:space:].:]/ /g' )"
      myYR="$( echo "${thisDATE:-UNDEF}" | awk '{print $1}' )"
    myYR="${myYR:--1}"
      myMO="$( echo "${thisDATE}" | awk '{print $2}' )"
    myMO="${myMO:--1}"
      myDA="$( echo "${thisDATE}" | awk '{print $3}' )"
    export myDA="${myDA:--1}"
      myHR="$( echo "${thisDATE}" | awk '{print $4}' )"
    myHR="${myHR:-0}"
      myMN="$( echo "${thisDATE}" | awk '{print $5}' )"
    myMN="${myMN:-0}"
      mySC="$( echo "${thisDATE}" | awk '{print $6}' )"
    mySC="${mySC:-0}"
  thisDATE="$( getDate \
               --date="${myYR}-${myMO}-${myDA} ${myHR}:${myMN}:${mySC}" \
               --fmt='+%F %T' )"

  if [ $? -ne 0 ]; then
    procError "wrong date/format supplied" \
              "   Supplied Date = ${1:-UNDEF}" \
              "  Processed Date = ${myYR}-${myMO}-${myDA} ${myHR}:${myMN}:${mySC}"
  fi

  # Calculate the julian day (seconds) from REF_DATE
  jul0=$( getDate --date="${REF_DATE}" --fmt='+%s' )
  myJUL=$( getDate --date="${thisDATE}" --fmt='+%s' )
  myJUL=$(( ${myJUL} - ${jul0} ))

  thisDATE="$( echo "${thisDATE}" | sed 's/[-_/[:space:].:]/ /g' )"
  myYRStr="$( echo "${thisDATE}" | awk '{print $1}' )"
  myMOStr="$( echo "${thisDATE}" | awk '{print $2}' )"
  myDAStr="$( echo "${thisDATE}" | awk '{print $3}' )"
  myHRStr="$( echo "${thisDATE}" | awk '{print $4}' )"
  myMNStr="$( echo "${thisDATE}" | awk '{print $5}' )"
  mySCStr="$( echo "${thisDATE}" | awk '{print $6}' )"

  myYR="$( getPosInteger "${myYRStr}" )"
  myMO="$( getPosInteger "${myMOStr}" )"
  myDA="$( getPosInteger "${myDAStr}" )"
  myHR="$( getPosInteger "${myHRStr}" )"
  myMN="$( getPosInteger "${myMNStr}" )"
  mySC="$( getPosInteger "${mySCStr}" )"

  myDATE="${myYRStr}-${myMOStr}-${myDAStr}_${myHRStr}:${myMNStr}:${mySCStr}"

  export myDATE myJUL
  export myYR myMO myDA myHR myMN mySC
  export myYRStr myMOStr myDAStr myHRStr myMNStr mySCStr
}

GetStamp_Date()
{
  local nm_func="${FUNCNAME[0]}"

  local yr_str mo_str da_str hr_str mn_str sc_str

  if [ $# -lt 1 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} DateString"
  fi

  getInpTimeStamp "${1}"
    yr_str="${myYRStr}"
    mo_str="${myMOStr}"
    da_str="${myDAStr}"
    hr_str="${myHRStr}"
    mn_str="${myMNStr}"
    sc_str="${mySCStr}"
  unset myYR myMO myDA myHR myMN mySC myJUL
  unset myYRStr myMOStr myDAStr myHRStr myMNStr mySCStr myDATE

  echo -n ${yr_str}-${mo_str}-${da_str}_${hr_str}:${mn_str}:${sc_str}
}

# -------------------------------------------------------
# FirstLastDates()
# Usage:      FirstLastDates beg_date end_date
# Parameters: beg_date end_date
#             beg_date : the start date of the simulation
#                        (only the YEAR, MONTH and DAY OF MONTH fields
#                         are used here)
#             end_date : the end date of the simulation
#                        (only the YEAR, MONTH and DAY OF MONTH fields
#                         are used here)
#
# Returns:    0 (on success)
# Exports:    previousDATES firstDATES lastDATES nextDATES
# Echoes:     NONE
#
# Calculates the lists for:
#  "previous" : 1-day prior the "first" date(s)
#     "first" : first day(s) of the simulation, or the first day of the current month(s)
#      "last" : last date(s) of the simulation, or the last day of the current month(s)
#      "next" : 1-day after the "last" date(s)
# 
# -------------------------------------------------------
FirstLastDates()
{
  local nm_func="${FUNCNAME[0]}"

  local sim_beg sim_end date_beg adv_hours=6
  local prev_date first_date last_date next_date
  local b_jul e_jul m_jul l_jul diff_jul
  local adv_date my_date
  local my_yr my_mo my_mo1 mo_days count

  unset previousDATES firstDATES lastDATES nextDATES

  if [ $# -lt 2 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} start_date end_date"
  fi

  sim_beg="$( strTrim "${1}" 2 )"
  sim_end="$( strTrim "${2}" 2 )"
  if [ -z "${sim_beg:-}" ] || [ -z "${sim_end:-}" ]; then
    procError "wrong date/format for the begin/end dates of the simulation" \
              "Supplied: SimBeg = ${sim_beg:-UNDEF}" \
              "          SimEnd = ${sim_end:-UNDEF}"
  fi

  sim_beg="$( getDate --date="${sim_beg}" --fmt='+%F %T' )"
  if [ $? -ne 0 ]; then
    procError "wrong date/format for the begin date of the simulation" \
              "Supplied: SimBeg = ${1}"
  fi

  sim_end="$( getDate --date="${sim_end}" --fmt='+%F %T' )"
  if [ $? -ne 0 ]; then
    procError "wrong date/format for the end date of the simulation" \
              "Supplied: SimEnd = ${2}"
  fi

  date_beg=$( getDate --date="${sim_beg}" --fmt='+%Y-%m-01' )

  b_jul=$( getDate --date="${sim_beg}" --fmt='+%s' )
  e_jul=$( getDate --date="${sim_end}" --fmt='+%s' )
  if [ ${e_jul} -lt ${b_jul} ]; then
    procError "wrong end date for the simulation: SimEnd >= SimBeg" \
              "Supplied: SimBeg = ${1}" \
              "          SimEnd = ${2}"
  fi

  ####################
  # This section is when the requested simulation length
  # is less or equal to one month
   my_yr="$( echo "${sim_beg}" | sed -e 's/[;:,_\/-]/ /g' | awk '{print $1}' )"
   my_mo="$( echo "${sim_beg}" | sed -e 's/[;:,_\/-]/ /g' | awk '{print $2}' )"
  my_mo1="$( echo "${sim_end}" | sed -e 's/[;:,_\/-]/ /g' | awk '{print $2}' )"

  mo_days=$( getMonthDays ${my_yr} ${my_mo} )
  diff_jul=$(( (${e_jul} - ${b_jul}) / 86400 ))

  if [ ${diff_jul} -le ${mo_days} -a ${my_mo} -eq ${my_mo1} ]; then
    first_date="$( getDate --date="${sim_beg}" --fmt='+%F_%T' )"
    last_date="$( getDate --date="${sim_end}" --fmt='+%F_%T' )"

      adv_date="$( getDate --date="${sim_beg}" ) -${adv_hours} hours"
    prev_date="$( getDate --date="${adv_date}" --fmt='+%F_00:00:00' )"

      adv_date="$( getDate --date="${sim_end}" ) +1 days +${adv_hours} hours"
    next_date="$( getDate --date="${adv_date}" --fmt='+%F_00:00:00' )"

    previousDATES="${prev_date}"
    firstDATES="${first_date}"
    lastDATES="${last_date}"
    nextDATES="${next_date}"

    export previousDATES firstDATES lastDATES nextDATES

    return 0
  fi


  ####################
  # This section is when the requested simulation length
  # spans more than one month
  count=0
  m_jul=${b_jul}
  my_date="${date_beg}"
  while [ ${m_jul} -lt ${e_jul} ]
  do
    first_date="${my_date}"
    [ ${m_jul} -le ${b_jul} ] && first_date="${sim_beg}"

    my_yr="$( echo "${my_date}" | sed -e 's/[;:,_\/-]/ /g' | awk '{print $1}' )"
    my_mo="$( echo "${my_date}" | sed -e 's/[;:,_\/-]/ /g' | awk '{print $2}' )"
    mo_days="$( getMonthDays ${my_yr} ${my_mo} )"

      adv_date="$( echo "${my_date}" | sed "s/\(.*-.*-\)\(.*\)/\1${mo_days}/g" )"
      adv_date="$( getDate --date="${adv_date}") +1 days"
    last_date="$( getDate --date="${adv_date}" --fmt='+%F 00:00:00' )"
    l_jul="$( getDate --date="${last_date}" --fmt='+%s' )"
    [ ${l_jul} -ge ${e_jul} ] && last_date="${sim_end}"

      adv_date="$( getDate --date="${first_date}" ) -${adv_hours} hours"
    prev_date="$( getDate --date="${adv_date}" --fmt='+%F 00:00:00' )"

      adv_date="$( getDate --date="${last_date}" ) +1 days +${adv_hours} hours"
    next_date="$( getDate --date="${adv_date}" --fmt='+%F 00:00:00' )"

    previousDATES[${count}]="$( getDate --date="${prev_date}" --fmt='+%F_%T' )"
    firstDATES[${count}]="$( getDate --date="${first_date}" --fmt='+%F_%T' )"
    lastDATES[${count}]="$( getDate --date="${last_date}" --fmt='+%F_%T' )"
    nextDATES[${count}]="$( getDate --date="${next_date}" --fmt='+%F_%T' )"

    count=$(( ${count} + 1 ))
    adv_date="$( getDate --date="${date_beg}" ) +${count} month"
    my_date="$( getDate --date="${adv_date}" --fmt='+%F' )"
    m_jul="$( getDate --date="${my_date}" --fmt='+%s' )"
  done

  previousDATES="${previousDATES[*]}"
  firstDATES="${firstDATES[*]}"
  lastDATES="${lastDATES[*]}"
  nextDATES="${nextDATES[*]}"
  
  export previousDATES firstDATES lastDATES nextDATES

  return 0
}
############################################################


############################################################
##### NETCDF/GRIB FUNCTIONS
############################################################
# -------------------------------------------------------
# isNcdf()
# Usage:      isNcdf filename
# Parameters: filename
# Returns:    0 if filename is a valid NetCDF file (that is no error)
#             1 in any other case (that is error)
# Exports:    NONE
# Echoes:     "classic", "64-bit offset2" or ""
#
# Checks if the file "filename" is a valid NetCDF file.
# -------------------------------------------------------
isNcdf()
{
  local fname
  local chk_str typ_str typ_ver out_str
  local -i retval=1

  fname="$(strTrim "${1}" 2 )"
  if ! $( checkFILE -r "${fname}" ); then
    echo -n ${out_str}
    return ${retval}
  fi

  chk_str="$( od -An -c -N4 "${fname}" | grep -vi "command.*not.*found" )"
  typ_str="$( echo -e "${chk_str}" | sed 's/[^[:alpha:]]//g' | tr '[:lower:]' '[:upper:]' )"
  typ_ver="$( echo -e "${chk_str}" | sed 's/[^[:digit:]]//g' )"

  [ "${typ_str}" = "CDF" -a "${typ_ver}" = "001" ] && out_str="classic"
  [ "${typ_str}" = "CDF" -a "${typ_ver}" = "002" ] && out_str="64-bit offset"
  [ -n "${out_str:+1}" ] && retval=0
  
  echo -n ${out_str}
  return ${retval}
}

# -------------------------------------------------------
# isGrib()
# Usage:      isGrib filename
# Parameters: filename
# Returns:    0 if filename is a valid GRIB file (that is no error)
#             1 in any other case (that is error)
# Exports:    NONE
# Echoes:     "grib1" or "grib2"
#
# Checks if the file "filename" is a valid GRIB file.
# -------------------------------------------------------
isGrib()
{
  local fname
  local chk_str typ_str typ_ver out_str
  local -i retval=1

  fname="$(strTrim "${1}" 2 )"
  if ! $( checkFILE -r "${fname}" ); then
    echo -n ${out_str}
    return ${retval}
  fi

  chk_str="$( od -An -c -N8 "${fname}" | grep -vi "command.*not.*found" )"
  typ_str="$( echo -e "${chk_str}" | sed 's/[^[:alpha:]]//g' | tr '[:lower:]' '[:upper:]' )"
  typ_ver="$( echo -e "${chk_str}" | sed 's/[^[:digit:]]//g' )"

  [ "${typ_str}" = "GRIB" -a "${typ_ver}" = "001" ] && out_str="grib1"
  [ "${typ_str}" = "GRIB" -a "${typ_ver}" = "002" ] && out_str="grib2"
  [ -n "${out_str:+1}" ] && retval=0

  echo -n ${out_str}
  return ${retval}
}

# -------------------------------------------------------
# ncdf_getTimeStamp()
# Usage:      ncdf_getTimeStamp filename
# Parameters: filename
# Returns:    0 if the datestamp in the NetCDF file is determined (that is no error)
#             1 in any other case (that is error)
# Exports:    NONE
# Echoes:     Datestamp of the records in the NetCDF file
#
# Get the record datestamp from the NetCDF file "filename".
# -------------------------------------------------------
ncdf_getTimeStamp()
{
  local fname ftype
  local dim_str dim_val
  local var_str var_val
  local date_str idate
  local -i retval=1

  local NCDF_VAR_NAMES NCDF_VAR_VALUES

  fname="$(strTrim "${1}" 2 )"

  # First check if is this a NetCDF file.
  ftype="$( isNcdf "${fname}" )"
  if [ $? -ne 0 ]; then
    echo -n ${date_str}
    return ${retval}
  fi
  
  # First try to use "cdo" (Climate Data Operators) because
  # they produce a more elegant solution. If the program is not
  # in the user's PATH, proceed to use ncks/ncdump.
  var_str="$( cdo -V 2>&1 | grep -i "climate.*operator" )"
  if [ -n "${var_str:+1}" ]; then
    var_str="$( strRmDuplicate "$( cdo -s showtimestamp "${fname}" 2>/dev/null )" )"
    retval=$?
    if [ ${retval} -eq 0 ]; then
      for idate in ${var_str}
      do
        idate="$( echo "${idate}" | sed 's/T/ /g' )"
        idate="$( getDate --date="${idate}" --fmt='+%F_%T' )"
        if [ $? -ne 0 ]; then
          date_str=
          retval=1
          break
        fi
        date_str="${date_str} ${idate}"
      done
    fi
    echo -n $( strTrim "${date_str}" 2 )
    return ${retval}
  fi

  # If the above block of code fails proceed to use ncdump.
  var_str="$( ncdump 2>&1 | grep -i "netcdf" )"
  if [ -n "${var_str:+1}" ]; then
    var_str="$( ncdf_getDim "${fname}" "time" )"
    if [ $? -ne 0 ]; then
      echo -n
      return 1
    fi

    dim_str="$( echo "${var_str}" | awk '{print $1}' )"
    dim_val="$( echo "${var_str}" | awk '{print $2}' )"

    # This is hopefully the time variable
    var_val=$( echo $( ncdump -t -v "${dim_str}" "${fname}" 2>&1 | \
                       sed -e '1,/data:/d' -e '/^}/,$d' | \
                       sed -e 's/.*=//g; s/[;"\{\}]//g' ) )
    retval=$?

    if [ ${retval} -eq 0 ]; then
      IFS=','
      for idate in ${var_val}
      do
        idate="$( strTrim "${idate}" 2)"
        if [ -n "${idate:+1}" ]; then
          idate="$( getDate --date="${idate}" --fmt='+%F_%T' )"
          if [ $? -ne 0 ]; then
            date_str=
            retval=1
            break
          fi
          date_str="${date_str} ${idate}"
        fi
      done
      unset IFS
    fi
    echo -n $( strTrim "${date_str}" 2 )
    return ${retval}
  fi

  echo -n ${date_str}
  return ${retval}
}

# -------------------------------------------------------
# grib_getTimeStamp()
# Usage:      grib_getTimeStamp filename
# Parameters: filename
# Returns:    0 if the datestamp in the grib file is determined (that is no error)
#             1 in any other case (that is error)
# Exports:    NONE
# Echoes:     Datestamp of the records in the grib file
#
# Get the record datestamp from the GRIB file "filename".
# -------------------------------------------------------
grib_getTimeStamp()
{
  local fname ftype
  local chk_str date_str idate
  local yr mo da hr mn sc
  local -i retval=1

  fname="$(strTrim "${1}" 2 )"

  # First check if is this a GRIB file.
  ftype="$( isNcdf "${fname}" )"
  if [ $? -ne 0 ]; then
    echo -n ${date_str}
    return ${retval}
  fi

  # First try to use "cdo" (Climate Data Operators) because
  # they produce a more elegant solution. If the program is not
  # in the user's PATH, proceed to use wgrib/wgrib2.
  chk_str="$( cdo -V 2>&1 | grep -i "climate.*operator" )"
  if [ -n "${chk_str:+1}" ]; then
    export GRIB_INVENTORY_MODE=time
    chk_str="$( cdo -s showtimestamp "${fname}" 2>&1 | \
                tr " " "\n" | sort -u )"
    retval=$?
    unset GRIB_INVENTORY_MODE
    if [ ${retval} -eq 0 ]; then
      for idate in ${chk_str}
      do
        idate="$( echo "${idate}" | sed 's/T/ /g' )"
        idate="$( getDate --date="${idate}" --fmt='+%F_%T' )"
        if [ $? -ne 0 ]; then
          date_str=
          retval=1
          break
        fi
        date_str="${date_str} ${idate}"
      done
    fi
    echo -n ${date_str}
    return ${retval}
  fi

  # If the above block of code fails proceed to use wgrib/wgrib2.
  # GRIB1
  if [ "${ftype}" = "grib1" ]; then
    chk_str="$( wgrib 2>&1 | grep -i '^[[:space:]]*usage:[[:space:]]*wgrib' )"
    if [ -n "${chk_str:+1}" ]; then
      chk_str="$( wgrib -s -4yr "${fname}" 2>&1 | \
                  sed 's/^.*d=//g; s/:.*//g' | sort -u )"
      retval=$?
      if [ ${retval} -eq 0 ]; then
        for idate in ${chk_str}
        do
          yr="${idate:0:4}"
          mo="${idate:4:2}"
          da="${idate:6:2}"
          hr="${idate:8:2}"
          mn="${idate:10:2}"
          sc="${idate:12:2}"
          idate="${yr}-${mo}-${da} ${hr:-00}:${mn:-00}:${sc:-00}"
          idate="$( getDate --date="${idate}" --fmt='+%F_%T' )"
          if [ $? -ne 0 ]; then
            date_str=
            retval=1
            break
          fi
          date_str="${date_str} ${idate}"
        done
      fi
      echo -n ${date_str}
      return ${retval}
    fi
  fi

  # GRIB2
  if [ "${ftype}" = "grib2" ]; then
    chk_str="$( wgrib2 -version 2>&1 | \
                grep -vi 'command[[:space:]]*not[[:space:]]*found' )"
    if [ -n "${chk_str:+1}" ]; then
      chk_str="$( wgrib2 -VT "${fname}" | \
                  sed 's/^.*vt=//g; s/:.*//g' | sort -u )"
      retval=$?
      if [ ${retval} -eq 0 ]; then
        for idate in ${chk_str}
        do
          yr="${idate:0:4}"
          mo="${idate:4:2}"
          da="${idate:6:2}"
          hr="${idate:8:2}"
          mn="${idate:10:2}"
          sc="${idate:12:2}"
          idate="${yr}-${mo}-${da} ${hr:-00}:${mn:-00}:${sc:-00}"
          idate="$( getDate --date="${idate}" --fmt='+%F_%T' )"
          if [ $? -ne 0 ]; then
            date_str=
            retval=1
            break
          fi
          date_str="${date_str} ${idate}"
        done
      fi
      echo -n ${date_str}
      return ${retval}
    fi
  fi

  echo -n ${date_str}
  return ${retval}
}

# -------------------------------------------------------
# ncdf_getModDataFile()
# Usage:      ncdf_getModDataFile f{name/expr} search_dirs [[BegDate] [EndDate]]
# Parameters: fname or fexpr, search_dirs, BegDate EndDate
#             fname: the filename to search for (mandatory) OR
#             fexpr: the list of filename regular expressions
#                    to search for (mandatory)
#             search_dirs: the list of directories to search
#                          for the above files (mandatory)
#             BegDate: if only this date is present (in date command format)
#                      then this date should be also present in the NetCDF file;
#                      it is intented to be used to match the correct
#                      initialization files
#             EndDate: if this parameter is used in addition to BegDate then
#                      the Netcdf file should contain sufficient time records
#                      that bound BegDate and EndDate; t is intented to be used
#                      to match boundary contition, forcing files.
#             NOTE: If none of BegDate and EndDate are supplied the file found
#                   is only checked if it is a valid NetCDF file.
# Returns:    0 if a valid file found (success)
#             1 in any other case (error)
# Exports:    NONE
# Echoes:     NONE
#
# Find the NetCDF file that meets the user's criteria.
# -------------------------------------------------------
ncdf_getModDataFile()
{
  local nargs
  local fexpr fdirs b_date e_date
  local my_b_date my_e_date
  local c_file c_date c_jul1 c_jul2 id
  local -i retval=1

  unset foundFilePath

  nargs=$#
  fexpr="${1}"
  fdirs="${2}"
  my_b_date="${3}"
  my_e_date="${4}"

  case 1 in
    $(( ${nargs} == 2 )) )
      searchFILE "${fexpr}" "${fdirs}"
      c_file="$( echo ${foundFilePath} | awk '{print $1}' )"
      unset foundFilePath
      if [ -z "${c_file:-}" ]; then
        procError "no valid files found" \
                  "checked for files(s): ${fexpr}" \
                  "     checked in dirs: ${fdirs}"
      fi

      if [ -z "$(isNcdf "${c_file}")" ]; then
        procError "the file found is not a valid NetCDF file" \
                  "                file: ${c_file}" \
                  "checked for files(s): ${fexpr}" \
                  "     checked in dirs: ${fdirs}"
      fi

      retval=0
    ;;
    $(( ${nargs} == 3 )) )
      b_date="$( echo "${my_b_date}" | sed 's/_/ /g' )"
      b_date="$( getDate --date="${b_date}" --fmt='+%F %T' )"
      if [ $? -ne 0 ]; then
        procError "wrong \"BegDate\" date supplied." \
                  "BegDate = ${my_b_date}"
      fi
      b_jul=$( getDate --date="${b_date}" --fmt='+%s' )

      searchFILE "${fexpr}" "${fdirs}"
      c_file="$( echo ${foundFilePath} | awk '{print $1}' )"
      unset foundFilePath
      if [ -z "${c_file:-}" ]; then
        procError "no valid files found" \
                  "checked for files(s): ${fexpr}" \
                  "     checked in dirs: ${fdirs}"
      fi

      c_date=( $( ncdf_getTimeStamp "${c_file}" ) )
      for ((id=0; id<${#c_date[@]}; id++))
      do
          c_jul1="$( echo "${c_date[${id}]}" | sed 's/_/ /g' )"
        c_jul1="$( getDate --date="${c_jul1}" --fmt='+%s' )"
        if [ ${b_jul} -eq ${c_jul1} ]; then
          retval=0
          break
        fi
      done

      if [ ${retval} -ne 0 ]; then
        procError "wrong date(s) found in the file." \
                  "File     = ${c_file}" \
                  "FileDate = ${c_date[*]}" \
                  "BegDate  = ${my_b_date}"
      fi
    ;;
    $(( ${nargs} >= 4 )) )
      b_date="$( echo "${my_b_date}" | sed 's/_/ /g' )"
      b_date="$( getDate --date="${b_date}" --fmt='+%F %T' )"
      if [ $? -ne 0 ]; then
        procError "wrong \"BegDate\" date supplied." \
                  "BegDate = ${my_b_date}"
      fi
      b_jul=$( getDate --date="${b_date}" --fmt='+%s' )

      e_date="$( echo "${my_e_date}" | sed 's/_/ /g' )"
      e_date="$( getDate --date="${e_date}" --fmt='+%F %T' )"
      if [ $? -ne 0 ]; then
        procError "wrong \"BegDate\" date supplied." \
                  "BegDate = ${my_e_date}"
      fi
      e_jul=$( getDate --date="${e_date}" --fmt='+%s' )

      searchFILE "${fexpr}" "${fdirs}"
      c_file="$( echo ${foundFilePath} | awk '{print $1}' )"
      unset foundFilePath
      if [ -z "${c_file:-}" ]; then
        procError "no valid files found" \
                  "checked for files(s): ${fexpr}" \
                  "     checked in dirs: ${fdirs}"
      fi

      c_date=( $( ncdf_getTimeStamp "${c_file}" ) )
        c_jul1="$( echo "${c_date[0]}" | sed 's/_/ /g' )"
      c_jul1="$( getDate --date="${c_jul1}" --fmt='+%s' )"
        c_jul2="$( echo "${c_date[${#c_date[@]}-1]}" | sed 's/_/ /g' )"
      c_jul2="$( getDate --date="${c_jul2}" --fmt='+%s' )"

      if [ ${b_jul} -ge ${c_jul1} -a ${b_jul} -le ${c_jul2} -a \
           ${e_jul} -ge ${c_jul1} -a ${e_jul} -le ${c_jul2} ]; then
        retval=0
      fi

      if [ ${retval} -ne 0 ]; then
        procError "wrong dates found in the file." \
                  "File     = ${c_file}" \
                  "FileDate = ${c_date[*]}" \
                  "BegDate  = ${my_b_date}" \
                  "EndDate  = ${my_e_date}"
      fi
    ;;
    *)
      procError "wrong number of arguments" \
                "usage: ${nm_func} \"fname_expr\" \"dirs_to_search\" [[BegDate] [EndDate]]"
    ;;
  esac

  export foundFilePath="${c_file}"
  return ${retval}
}

# -------------------------------------------------------
# grib_getModDataFile()
# Usage:      grib_getModDataFile f{name/expr} search_dirs [[BegDate] [EndDate]]
# Parameters: fname or fexpr, search_dirs, BegDate EndDate
#             fname: the filename to search for (mandatory) OR
#             fexpr: the list of filename regular expressions
#                    to search for (mandatory)
#             search_dirs: the list of directories to search
#                          for the above files (mandatory)
#             BegDate: if only this date is present (in date command format)
#                      then this date should be also present in the GRIB file;
#                      it is intented to be used to match the correct
#                      initialization files
#             EndDate: if this parameter is used in addition to BegDate then
#                      the Netcdf file should contain sufficient time records
#                      that bound BegDate and EndDate; t is intented to be used
#                      to match boundary contition, forcing files.
#             NOTE: If none of BegDate and EndDate are supplied the file found
#                   is only checked if it is a valid GRIB file.
# Returns:    0 if a valid file found (success)
#             1 in any other case (error)
# Exports:    NONE
# Echoes:     NONE
#
# Find the GRIB file that meets the user's criteria.
# -------------------------------------------------------
grib_getModDataFile()
{
  local nargs
  local fexpr fdirs b_date e_date
  local my_b_date my_e_date
  local c_file c_date c_jul1 c_jul2 id
  local -i retval=1

  unset foundFilePath

  nargs=$#
  fexpr="${1}"
  fdirs="${2}"
  my_b_date="${3}"
  my_e_date="${4}"

  case 1 in
    $(( ${nargs} == 2 )) )
      searchFILE "${fexpr}" "${fdirs}"
      c_file="$( echo ${foundFilePath} | awk '{print $1}' )"
      unset foundFilePath
      if [ -z "${c_file:-}" ]; then
        procError "no valid files found" \
                  "checked for files(s): ${fexpr}" \
                  "     checked in dirs: ${fdirs}"
      fi

      if [ -z "$(isGrib "${c_file}")" ]; then
        procError "the file found is not a valid GRIB file" \
                  "                file: ${c_file}" \
                  "checked for files(s): ${fexpr}" \
                  "     checked in dirs: ${fdirs}"
      fi

      retval=0
    ;;
    $(( ${nargs} == 3 )) )
      b_date="$( echo "${my_b_date}" | sed 's/_/ /g' )"
      b_date="$( getDate --date="${b_date}" --fmt='+%F %T' )"
      if [ $? -ne 0 ]; then
        procError "wrong \"BegDate\" date supplied." \
                  "BegDate = ${my_b_date}"
      fi
      b_jul=$( getDate --date="${b_date}" --fmt='+%s' )

      searchFILE "${fexpr}" "${fdirs}"
      c_file="$( echo ${foundFilePath} | awk '{print $1}' )"
      unset foundFilePath
      if [ -z "${c_file:-}" ]; then
        procError "no valid files found" \
                  "checked for files(s): ${fexpr}" \
                  "     checked in dirs: ${fdirs}"
      fi

      c_date=( $( grib_getTimeStamp "${c_file}" ) )
      for ((id=0; id<${#c_date[@]}; id++))
      do
          c_jul1="$( echo "${c_date[${id}]}" | sed 's/_/ /g' )"
        c_jul1="$( getDate --date="${c_jul1}" --fmt='+%s' )"
        if [ ${b_jul} -eq ${c_jul1} ]; then
          retval=0
          break
        fi
      done

      if [ ${retval} -ne 0 ]; then
        procError "wrong date(s) found in the file." \
                  "File     = ${c_file}" \
                  "FileDate = ${c_date[*]}" \
                  "BegDate  = ${my_b_date}"
      fi
    ;;
    $(( ${nargs} >= 4 )) )
      b_date="$( echo "${my_b_date}" | sed 's/_/ /g' )"
      b_date="$( getDate --date="${b_date}" --fmt='+%F %T' )"
      if [ $? -ne 0 ]; then
        procError "wrong \"BegDate\" date supplied." \
                  "BegDate = ${my_b_date}"
      fi
      b_jul=$( getDate --date="${b_date}" --fmt='+%s' )

      e_date="$( echo "${my_e_date}" | sed 's/_/ /g' )"
      e_date="$( getDate --date="${e_date}" --fmt='+%F %T' )"
      if [ $? -ne 0 ]; then
        procError "wrong \"BegDate\" date supplied." \
                  "BegDate = ${my_e_date}"
      fi
      e_jul=$( getDate --date="${e_date}" --fmt='+%s' )

      searchFILE "${fexpr}" "${fdirs}"
      c_file="$( echo ${foundFilePath} | awk '{print $1}' )"
      unset foundFilePath
      if [ -z "${c_file:-}" ]; then
        procError "no valid files found" \
                  "checked for files(s): ${fexpr}" \
                  "     checked in dirs: ${fdirs}"
      fi

      c_date=( $( grib_getTimeStamp "${c_file}" ) )
        c_jul1="$( echo "${c_date[0]}" | sed 's/_/ /g' )"
      c_jul1="$( getDate --date="${c_jul1}" --fmt='+%s' )"
        c_jul2="$( echo "${c_date[${#c_date[@]}-1]}" | sed 's/_/ /g' )"
      c_jul2="$( getDate --date="${c_jul2}" --fmt='+%s' )"

      if [ ${b_jul} -ge ${c_jul1} -a ${b_jul} -le ${c_jul2} -a \
           ${e_jul} -ge ${c_jul1} -a ${e_jul} -le ${c_jul2} ]; then
        retval=0
      fi

      if [ ${retval} -ne 0 ]; then
        procError "wrong dates found in the file." \
                  "File     = ${c_file}" \
                  "FileDate = ${c_date[*]}" \
                  "BegDate  = ${my_b_date}" \
                  "EndDate  = ${my_e_date}"
      fi
    ;;
    *)
      procError "wrong number of arguments" \
                "usage: ${nm_func} \"fname_expr\" \"dirs_to_search\" [[BegDate] [EndDate]]"
    ;;
  esac

  export foundFilePath="${c_file}"
  return ${retval}
}

# -------------------------------------------------------
# ncdf_queryDims()
# Usage:      ncdf_queryDims filename
# Parameters: filename
# Returns:    0 on success (that is no error)
# Exports:    NCDF_DIM_NAMES NCDF_DIM_VALUES
# Echoes:     NONE
#
# Queries all the dimensions (names and values)
# from the NetCDF file.
# -------------------------------------------------------
ncdf_queryDims()
{
  local nm_func="${FUNCNAME[0]}"
  local NCDUMP="ncdump"

  local fname tmp_var chk_var chk_val
  local var_names var_vals

  unset NCDF_DIM_TIME NCDF_DIM_NAMES NCDF_DIM_VALUES

  # Get the input filename
  fname="${1}"
  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${fname:-UNDEF}" \
              "usage: ${nm_func} filename [options]"
  fi

  # Check for the required programs
  chk_var="$( ${NCDUMP} 2>&1 | grep -i "netcdf" )"
  if [ -z "${chk_var:-}" ]; then
    procError "the required program \"${NCDUMP}\" is not available" \
              "cannot continue with the calculations"
  fi

  # Read only the dimensions section from the NetCDF file,
  # replace all occurences of "=" and ";" with space and
  # store the result in the multi-line string "tmp_var"
  tmp_var="$( ${NCDUMP} -h ${fname} 2>&1 | \
              sed -e '1,/^.*[Dd][Ii][Mm][Ee][Nn][Ss][Ii][Oo][Nn][Ss]:/d' \
                  -e '/^.*[Vv][Aa][Rr][Ii][Aa][Bb][Ll][Ee][Ss]/,$d' | \
              sed -e 's/[=;]/ /g' )"

  # Read "tmp_var" line by line and extract the names and the values
  # of all dimensions found in the NetCDF file
  while read -r line
  do
    if [ "X$( echo "${line}" | grep -i "unlimited" )" != "X" ]; then
      chk_var="$( echo "${line}" | awk '{print $1}' )"
      chk_val="$( echo "${line}" | \
                  sed -e 's/.*(\([0-9]*\).*[Cc][Uu][Rr][Rr][Ee][Nn][Tt].*).*/\1/' | \
                  awk '{print $1}' )"
      if [ -n "${chk_var:+1}" -a -n "${chk_val:+1}" ]; then
        var_names="${var_names} ${chk_var}"
        var_vals="${var_vals} ${chk_val}"
        # There is only one UNLIMITED variable
        NCDF_DIM_TIME="${chk_var}"
      fi
    else
      chk_var="$( echo "${line}" | awk '{print $1}' )"
      chk_val="$( echo "${line}" | awk '{print $2}' )"
      if [ -n "${chk_var:+1}" -a -n "${chk_val:+1}" ]; then
        var_names="${var_names} ${chk_var}"
        var_vals="${var_vals} ${chk_val}"
      fi
    fi
  done <<< "${tmp_var}"

  export NCDF_DIM_TIME
  export NCDF_DIM_NAMES="${var_names}"
  export NCDF_DIM_VALUES="${var_vals}"

  return 0
}

# -------------------------------------------------------
# ncdf_getDim()
# Usage:      ncdf_getDim filename dimtype
# Parameters: filename dimtype
# Returns:    0 on success (that is no error)
# Exports:    NONE
# Echoes:     the pair: dimNAM dimVAL
#
# Get the name and the value of the requested dimension
# from the NetCDF file.
# -------------------------------------------------------
ncdf_getDim()
{
  local nm_func="${FUNCNAME[0]}"

  local dtype chk_var
  local var_names var_vals var_time
  local dimNAM dimVAL

  local NCDF_DIM_TIME NCDF_DIM_NAMES NCDF_DIM_VALUES

  if [ $# -lt 2 ]; then
    dimNAM="wrong number of arguments
          usage: ${nm_func} filename dimtype"
    return 1
  fi

  # Get the list of dimension in the NetCDF file.
  ncdf_queryDims "${1}"
  var_names=( ${NCDF_DIM_NAMES} )
  var_vals=( ${NCDF_DIM_VALUES} )
  var_time=${NCDF_DIM_TIME}

  # Get the dimension type.
  dtype="$( toLOWER "${2}" )"

  case "${dtype}" in
    horx) chk_DIM="lon longitude x idim xi_rho west_east" ;;
    hory) chk_DIM="lat latitude y jdim eta_rho shouth_north" ;;
    vert) chk_DIM="depth z kdim s_rho bottom_top" ;;
    time) chk_DIM="${var_time:-time mt ocean_time bry_time clim_time}" ;;
    *)    chk_DIM="${dtype}" ;;
  esac

  for ((ivar = 0; ivar < ${#var_names[@]}; ivar++))
  do
    for chk_var in ${chk_DIM}
    do
      if [ "$( toLOWER "${var_names[${ivar}]}" )" = "${chk_var}" ]; then
        dimNAM="${var_names[${ivar}]}"
        dimVAL="${var_vals[${ivar}]}"
        break 2
      fi
    done
  done

  if [ -z "${dimNAM:-}" -o -z "${dimVAL:-}" ]; then
    echo -n
    return 1
  fi

  echo -n $( strTrim "${dimNAM} ${dimVAL}" 2 )

  return 0
}

# -------------------------------------------------------
# ncdf_queryVars()
# Usage:      ncdf_queryVars filename
# Parameters: filename
# Returns:    0 on success (that is no error)
# Exports:    NCDF_VAR_NAMES NCDF_VAR_VALUES
# Echoes:     NONE
#
# Queries all the variables (names)
# from the NetCDF file.
# -------------------------------------------------------
ncdf_queryVars()
{
  local nm_func="${FUNCNAME[0]}"
  local NCDUMP="ncdump" NCKS="ncks"
  local -i useNCKS=0

  local fname tmp_var chk_var chk_val
  local var_names var_vals

  unset NCDF_VAR_NAMES NCDF_VAR_VALUES

  # Get the input filename
  fname="${1}"
  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${fname:-UNDEF}" \
              "usage: ${nm_func} filename [options]"
  fi

  if [ ${useNCKS:-0} -le 0 ]; then
    # Check for the required programs
    chk_var="$( ${NCDUMP} 2>&1 | grep -i "netcdf" )"
    if [ -z "${chk_var:-}" ]; then
      procError "the required program \"${NCDUMP}\" is not available" \
                "cannot continue with the calculations"
    fi

    # Read only the variables section from the NetCDF file,
    # replace all occurences of "( = , ; )" with space and
    # store the result in the multi-line string "tmp_var"
    tmp_var="$( ${NCDUMP} -h ${fname} 2>&1 | \
                sed -e '1,/^.*[vV][aA][rR][iI][aA][bB][lL][eE][sS]:/d' \
                    -e '/^.*[Gg][Ll][Oo][Bb][Aa][Ll]/,$d' | \
                grep -v ':.*=' | \
                sed -e 's/[(=,;)]/ /g' | \
                awk '{print $2}' )"

    # "tmp_var" contains the list of all the variables
    # found in the NetCDF file
    var_names="$( echo ${tmp_var} )"
  else
    # Check for the required programs
    chk_var="$( ${NCKS} --version 2>&1 | grep -i "netcdf.*operator" )"
    if [ -z "${chk_var:-}" ]; then
      procError "the required program \"${NCKS}\" is not available" \
                "cannot continue with the calculations"
    fi

    tmp_var="$( ${NCKS} -m ${fname} | grep -i 'RAM' | cut -d ' ' -f 1 )"
    # "tmp_var" contains the list of all the variables
    # found in the NetCDF file
    var_names="$( echo ${tmp_var} )"
  fi

  export NCDF_VAR_NAMES="${var_names}"
  export NCDF_VAR_VALUES="${var_vals}"

  return 0
}

# -------------------------------------------------------
# ncdf_getGlobVar()
# Usage:      ncdf_getGlobVar filename global_variable_name
# Parameters: filename global_variable_name
# Returns:    0 on success (that is no error)
# Exports:    ncdfVarVal
# Echoes:     NONE
#
# Obtains the value of a global variable
# from the NetCDF file.
# -------------------------------------------------------
ncdf_getGlobVar()
{
  local nm_func="${FUNCNAME[0]}"

  local fname in_var
  local out_var

  unset ncdfVarVal

  if [ $# -lt 2 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename varname"
  fi

  fname="${1}"
  in_var="$( echo "${2}" | sed -e 's/[()]/\\\&/g' )"

  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${fname:-UNDEF}"
  fi

  out_var="$( ncdump -h ${fname} 2>&1 | grep -Ei "^[[:space:]]*${in_var}[[:space:]]*=" )"
  out_var="$( echo "${out_var}" | sed -e 's/.*=//g' | sed 's/[;:,_\{\}]/ /g' )"

  export ncdfVarVal="${out_var}"

  return 0
}

# -------------------------------------------------------
# ncdf_getVar()
# Usage:      ncdf_getVar filename variable_name
# Parameters: filename variable_name
# Returns:    0 on success (that is no error)
# Exports:    ncdfVarVal
# Echoes:     NONE
#
# Obtains the value of a variable
# from the NetCDF file.
# -------------------------------------------------------
ncdf_getVar()
{
  local nm_func="${FUNCNAME[0]}"

  local fname in_var in_opt
  local out_var

  unset ncdfVarVal

  if [ $# -lt 2 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename varname"
  fi

  fname="${1}"
  in_var="$( echo "${2}" | sed -e 's/[()]/\\\&/g' )"
  in_opt="${3:--v}"

  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${fname:-UNDEF}"
  fi

  out_var="$( ncdump ${in_opt} ${in_var} ${fname} 2>&1 | sed -e '1,/data:/d' -e '/^}/,$d' )"
  out_var=( $( echo "${out_var}" | sed -e 's/.*=//g' | sed 's/[;:,_\{\}]/ /g' ) )

  export ncdfVarVal="${out_var[@]}"

  return 0
}

# -------------------------------------------------------
# ncdf_getVarMax()
# Usage:      ncdf_getVarMax filename variable_name
# Parameters: filename variable_name
# Returns:    0 on success (that is no error)
# Exports:    NONE
# Echoes:     the maximum of the variable
#
# Obtains the maximum value of a variable
# from the NetCDF file.
# -------------------------------------------------------
ncdf_getVarMax()
{
  local nm_func="${FUNCNAME[0]}"

  local fname tmp_file in_var out_var

  if [ $# -lt 2 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename varname"
  fi

  fname="${1}"
  in_var="$( echo "${2}" | sed -e 's/[()]/\\\&/g' )"
  tmp_file="${fname%.*}-tmp.nc"

  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${1:-UNDEF}"
  fi

  ncwa -y max -O -C -v "${in_var}" "${fname}" "${tmp_file}" >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
    echo ""
    return 1
  fi

  out_var="$( ncks -H -C -s '%.6f' -v "${in_var}" "${tmp_file}" 2>/dev/null | cut -f 3- -d ' ' )"
  if [ $? -ne 0 ]; then
    [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
    echo ""
    return 1
  fi

  [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
  echo "$( strTrim "${out_var}" 2 )"

  return 0
}

# -------------------------------------------------------
# ncdf_getVarMin()
# Usage:      ncdf_getVarMin filename variable_name
# Parameters: filename variable_name
# Returns:    0 on success (that is no error)
# Exports:    NONE
# Echoes:     the minimum of the variable
#
# Obtains the minimum value of a variable
# from the NetCDF file.
# -------------------------------------------------------
ncdf_getVarMin()
{
  local nm_func="${FUNCNAME[0]}"

  local fname tmp_file in_var out_var

  if [ $# -lt 2 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename varname"
  fi

  fname="${1}"
  in_var="$( echo "${2}" | sed -e 's/[()]/\\\&/g' )"
  tmp_file="${fname%.*}-tmp.nc"

  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${1:-UNDEF}"
  fi

  ncwa -y min -O -C -v "${in_var}" "${fname}" "${tmp_file}" >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
    echo ""
    return 1
  fi

  out_var="$( ncks -H -C -s '%.6f' -v "${in_var}" "${tmp_file}" 2>/dev/null | cut -f 3- -d ' ' )"
  if [ $? -ne 0 ]; then
    [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
    echo ""
    return 1
  fi

  [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
  echo "$( strTrim "${out_var}" 2 )"

  return 0
}

# -------------------------------------------------------
# ncdf_getVarMean()
# Usage:      ncdf_getVarMean filename variable_name
# Parameters: filename variable_name
# Returns:    0 on success (that is no error)
# Exports:    NONE
# Echoes:     the mean (average) of the variable
#
# Obtains the mean (average) of a variable
# from the NetCDF file.
# -------------------------------------------------------
ncdf_getVarMean()
{
  local nm_func="${FUNCNAME[0]}"

  local fname tmp_file in_var out_var

  if [ $# -lt 2 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename varname"
  fi

  fname="${1}"
  in_var="$( echo "${2}" | sed -e 's/[()]/\\\&/g' )"
  tmp_file="${fname%.*}-tmp.nc"

  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${1:-UNDEF}"
  fi

  ncwa -y avg -O -C -v "${in_var}" "${fname}" "${tmp_file}" >/dev/null 2>&1
  if [ $? -ne 0 ]; then
    [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
    echo ""
    return 1
  fi

  out_var="$( ncks -H -C -s '%.6f' -v "${in_var}" "${tmp_file}" 2>/dev/null | cut -f 3- -d ' ' )"
  if [ $? -ne 0 ]; then
    [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
    echo ""
    return 1
  fi

  [ -f "${tmp_file}" ] && rm -f "${tmp_file}"
  echo "$( strTrim "${out_var}" 2 )"

  return 0
}

# -------------------------------------------------------
# ncdf_getVarDims()
# Usage:      ncdf_getVarDims filename variable_name
# Parameters: filename variable_name
# Returns:    0 on success (that is no error)
# Exports:    NONE
# Echoes:     the dimensions of a variable (order: X, Y, Z, T)
#
# Obtains the dimensions of a variable
# from the NetCDF file.
# -------------------------------------------------------
ncdf_getVarDims()
{
  local nm_func="${FUNCNAME[0]}"

  local fname in_var tmp_var out_var
  local i j

  if [ $# -lt 2 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename varname"
  fi

  fname="${1}"
  in_var="$( echo "${2}" | sed -e 's/[()]/\\\&/g' )"

  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${1:-UNDEF}"
  fi

  out_var="$( ncks -m -M "${fname}"  2>/dev/null | grep -E -i "^${in_var}.*dimension.*:.*size" | cut -f 7 -d ' ' )"
  if [ $? -ne 0 ]; then
    echo ""
    return 1
  fi

  j=0
  out_var=( $( strTrim "${out_var}" 2 ) )
  for ((i=$(( ${#out_var[@]} - 1 )); i>=0; i--))
  do
    tmp_var[j]=${out_var[i]}
    j=$(( ${j} + 1 ))
  done
  out_var="${tmp_var[*]}"

  echo "${out_var}"

  return 0
}

# -------------------------------------------------------
# SSTnc2grib()
# Usage:      SSTnc2grib filename
# Parameters: filename
# Returns:    0 on success (that is no error)
# Exports:    NONE
# Echoes:     NONE
#
# Creates a GRIB file from the input NetCDF filename
# and for the sea surface temperature.
# -------------------------------------------------------
SSTnc2grib()
{
  local nm_func="${FUNCNAME[0]}"
  local CDO="cdo" NCKS="ncks" NCDUMP="ncdump"

  local fname fname_pfx inp_file inp_dir inp_bas
  local out_file out_grib grid_file weight_file

  local xdimNAM ydimNAM my_xdimNAM my_ydimNAM
  local xdimVAL ydimVAL
  local lonNAM latNAM my_lonNAM my_latNAM
  local varNAM my_varNAM grib_type tmp_var
  local var_names var_vals ivar chk_var
  local chk_xNAM chk_yNAM chk_vNAM

  local ngrd
  local dim_lon min_lon max_lon dlon nlons nlons1
  local dim_lat min_lat max_lat dlat nlats nlats1

  local opt_all opt_opt opt_arg


  # Get the input filename
  fname="${1}"
  if [ -z "$(isNcdf "${fname}")" ]; then
    procError "the input filename is not a valid NetCDF file" \
              "supplied: FILENAME = ${fname:-UNDEF}" \
              "usage: ${nm_func} filename [options]"
  fi


  # -----
  # Process the function options
  # Get the remaining optional arguments
  opt_all=( pfx lon lat var xdim ydim gtype )
  opt_all=":$( echo "${opt_all[@]/#/-} ${opt_all[@]/#/--}" | sed 's/ /:/g' ):"

  __OPTION_LIST=
  while test $# -gt 0; do
    case "${1}" in
      -[^-]*=* | --[^-]*=* )
        opt_opt="$( toLOWER "$( echo "${1}" | sed 's/=.*//' )" )"
        opt_arg="$( strTrim "$( echo "${1}" | sed 's/.*=//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      -[^-]* | --[^-]* )
        opt_opt="$( toLOWER "${1}" )"
        opt_arg="$( strTrim "$( echo "${2}" | sed 's/=.*//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      *)
        opt_opt= 
        opt_arg=
        ;;
    esac

    case "${opt_opt}" in
      -pfx | --pfx )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            fname_pfx="${opt_arg}"
          fi
        ;;
      -lon | --lon )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            my_lonNAM="${opt_arg}"
          fi
        ;;
      -lat | --lat )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            my_latNAM="${opt_arg}"
          fi
        ;;
      -var | --var )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            my_varNAM="${opt_arg}"
          fi
        ;;
      -xdim | --xdim )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            my_xdimNAM="${opt_arg}"
          fi
        ;;
      -ydim | --ydim )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            my_ydimNAM="${opt_arg}"
          fi
        ;;
      -gtype | --gtype )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
            grib_type="${opt_arg}"
          fi
        ;;
      *) ;; # DEFAULT
    esac
    shift
    opt_opt= 
    opt_arg=
  done
  __OPTION_LIST=
  # -----

  # Check for the required programs
  chk_var="$( ${NCDUMP} 2>&1 | grep -i "netcdf" )"
  if [ -z "${chk_var:-}" ]; then
    procError "the required program \"${NCDUMP}\" is not available" \
              "cannot continue with the calculations"
  fi

  chk_var="$( ${CDO} -V 2>&1 | grep -i "climate.*operator" )"
  if [ -z "${chk_var:-}" ]; then
    procError "the required program \"${CDO}\" is not available" \
              "cannot continue with the calculations"
  fi

  # Determine/Set the grib format type: one of grib/grib2
  #echo "grib_type = ${grib_type}"
  grib_type="$( toLOWER "${grib_type}" )"
  [ "${grib_type}" != "grib1" -a "${grib_type}" != "grib2" ] && grib_type="grib1"

  # Determine a name for the output file
  inp_file="${fname}"
  inp_dir=$( dirname ${fname} )
    [ "X${inp_dir}" = "X." ] && inp_dir=
  inp_bas=$( basename ${fname} )
  if [ -z "${fname_pfx:-}" ]; then
    out_file="${inp_dir:+${inp_dir}/}sst_${inp_bas}"
  else
    out_file="${inp_bas##${fname_pfx}}"
    out_file="${inp_dir:+${inp_dir}/}${fname_pfx%%_}-sst_${out_file}"
  fi


  ########################
  # Check if the required dimensions exist in the input NetCDF file
  tmp_var="$( ncdf_getDim ${inp_file} ${my_xdimNAM:-horx} )"
  if [ $? -ne 0 ]; then
    procError "could not find the required horizontal dimension in the input file:" \
              "INP FILE = ${inp_file}" \
              "SEARCHED FOR: ${my_xdimNAM:-horx}"
  fi
  xdimNAM="$( echo ${tmp_var} | awk '{print $1}' )"

  tmp_var="$( ncdf_getDim ${inp_file} ${my_ydimNAM:-hory} )"
  if [ $? -ne 0 ]; then
    procError "could not find the required horizontal dimension in the input file:" \
              "INP FILE = ${inp_file}" \
              "SEARCHED FOR: ${my_ydimNAM:-hory}"
  fi
  ydimNAM="$( echo ${tmp_var} | awk '{print $1}' )"
  ########################


  ########################
  # Check if the required variables exist in the input NetCDF file
  ncdf_queryVars ${inp_file}
  var_names=( ${NCDF_VAR_NAMES} )
  unset NCDF_VAR_NAMES NCDF_VAR_VALUES

  chk_xNAM="longitude lon lons lon_rho xlong"
  chk_yNAM="latitude lat lats lat_rho xlat"
  chk_vNAM="temperature temp water_temperature water_temp sst"

  for ((ivar = 0; ivar < ${#var_names[@]}; ivar++))
  do
    # Check for a "Longitude" variable
    if [ -z "${lonNAM:-}" ]; then
      if [ -n "${my_lonNAM:+1}" ]; then
        if [ "$( toLOWER "${var_names[${ivar}]}" )" = "$( toLOWER "${my_lonNAM}" )" ]; then
          lonNAM="${var_names[${ivar}]}"
        fi
      else
        for chk_var in ${chk_xNAM}
        do
          if [ "$( toLOWER "${var_names[${ivar}]}" )" = "${chk_var}" ]; then
            lonNAM="${var_names[${ivar}]}"
            break
          fi
        done
      fi
    fi

    # Check for a "Latitude" variable
    if [ -z "${latNAM:-}" ]; then
      if [ -n "${my_latNAM:+1}" ]; then
        if [ "$( toLOWER "${var_names[${ivar}]}" )" = "$( toLOWER "${my_latNAM}" )" ]; then
          latNAM="${var_names[${ivar}]}"
        fi
      else
        for chk_var in ${chk_yNAM}
        do
          if [ "$( toLOWER "${var_names[${ivar}]}" )" = "${chk_var}" ]; then
            latNAM="${var_names[${ivar}]}"
            break
          fi
        done
      fi
    fi

    # Check for a "Temperature" variable
    if [ -z "${varNAM:-}" ]; then
      if [ -n "${my_varNAM:+1}" ]; then
        if [ "$( toLOWER "${var_names[${ivar}]}" )" = "$( toLOWER "${my_varNAM}" )" ]; then
          varNAM="${var_names[${ivar}]}"
        fi
      else
        for chk_var in ${chk_vNAM}
        do
          if [ "$( toLOWER "${var_names[${ivar}]}" )" = "${chk_var}" ]; then
            varNAM="${var_names[${ivar}]}"
            break
          fi
        done
      fi
    fi

    [ -n "${lonNAM:+1}" -a -n "${latNAM:+1}" -a -n "${varNAM:+1}" ] && break
  done

  if [ -z "${varNAM:-}" ]; then
    procError "could not find the required variable in the input file:" \
              "INP FILE = ${inp_file}" \
              "VARS IN FILE: ${var_names[*]}" \
              "SEARCHED FOR: ${my_varNAM:+${my_varNAM}}${my_varNAM:=${chk_vNAM}}"
  fi
  ########################


  ########################
  # Create the grid file to be used with the CDO command
 if [ -n "${lonNAM:+1}" -a -n "${latNAM:+1}" ]; then
   grid_file="${out_file%.*}-cdo_grid.txt"
   weight_file="${out_file%.*}-cdo_weight.nc"
   [ -f "${grid_file}" ] && rm -f "${grid_file}"

   ##### Work on the "Longitude" variable
   dim_lon=( $( ncdf_getVarDims "${inp_file}" "${lonNAM}" ) )
   if [ ${#dim_lon[@]} -eq 0 ]; then
     procError "error determining the dimensions of \"${lonNAM}\"" \
               "cannot continue with the calculations"
   fi

   nlons=${dim_lon[0]}
   nlons1=$(( ${nlons} - 1 ))
   min_lon="$( ncdf_getVarMin "${inp_file}" "${lonNAM}" )"
   max_lon="$( ncdf_getVarMax "${inp_file}" "${lonNAM}" )"
   dlon="$( echo "scale=5; (${max_lon} - ${min_lon}) / ${nlons1}" | bc -ql 2>/dev/null )"

   ##### Work on the "Latitude" variable
   dim_lat=( $( ncdf_getVarDims "${inp_file}" "${latNAM}" ) )
   if [ ${#dim_lat[@]} -eq 0 ]; then
     procError "error determining the dimensions of \"${latNAM}\"" \
               "cannot continue with the calculations"
   fi

   nlats=${dim_lat[0]}
   [ ${#dim_lat[@]} -gt 1 ] && nlats=${dim_lat[1]}
   nlats1=$(( ${nlats} - 1 ))
   min_lat="$( ncdf_getVarMin "${inp_file}" "${latNAM}" )"
   max_lat="$( ncdf_getVarMax "${inp_file}" "${latNAM}" )"
   dlat="$( echo "scale=6; (${max_lat} - ${min_lat}) / ${nlats1}" | bc -ql 2>/dev/null )"

   ##### Create the grid file
   ngrd=$(( ${nlons} * ${nlats} ))
   echo "gridtype = lonlat"      >> ${grid_file}
   echo "gridsize = ${ngrd}"     >> ${grid_file}
   echo "xsize    = ${nlons}"    >> ${grid_file}
   echo "ysize    = ${nlats}"    >> ${grid_file}
   echo "xfirst   = ${min_lon}"  >> ${grid_file}
   echo "xinc     = ${dlon}"     >> ${grid_file}
   echo "yfirst   = ${min_lat}"  >> ${grid_file}
   echo "yinc     = ${dlat}"     >> ${grid_file}
 fi
  ########################


  ########################
  # Get only the surface temperature and convert it to K from Celcius
  # and output the result to a NetCDF file
  [ -f ${out_file} ] && rm -f ${out_file}
  ${CDO} -s -f nc copy -selvar,${varNAM} -sellevel,0 ${inp_file} ${out_file} 2>/dev/null
  if [ $? -ne 0 ]; then
    procError "error creating ${out_file} using \"${CDO}\"" \
              "cannot continue with the calculations"
  fi

  # Convert the above NetCDF file to grib or grib2 formatted file
  # We use the codes for GRIB1/GRIB2 as defined in Vtable.SST
  if [ "X${grib_type}" = "Xgrib1" ]; then
    out_grib="${out_file%.nc}.grb"
    [ -f ${out_grib} ] && rm -f ${out_grib}

    ${CDO} -s -r -f grb copy -selvar,${varNAM} -sellevel,0 -addc,273.15 \
           -setcode,11 -setltype,1 ${out_file} ${out_grib}
    if [ $? -ne 0 ]; then
      [ -f ${out_grib} ] && rm -f ${out_grib}
      procError "error creating ${out_grib} using \"${CDO}\"" \
                "cannot continue with the calculations"
    fi
  else
    out_grib="${out_file%.nc}.grib2"
    [ -f ${out_grib} ] && rm -f ${out_grib}

    ${CDO} -s -r -f grb2 copy -selvar,${varNAM} -sellevel,0 -addc,273.15 \
           -setparam,0.0.0 ${out_file} ${out_grib}
    if [ $? -ne 0 ]; then
      [ -f ${out_grib} ] && rm -f ${out_grib}
      procError "error creating ${out_grib} using \"${CDO}\"" \
                "cannot continue with the calculations"
    fi
  fi

  # Remap the grid
  if [ -f "${grid_file}" ]; then
    [ -f "${weight_file}" ] && rm -f "${weight_file}"
    ${CDO} genbil,${grid_file} ${out_grib} ${weight_file}
    ${CDO} remap,${grid_file},${weight_file} ${out_grib} ${out_grib}_remapped
    mv -f ${out_grib}_remapped ${out_grib}
    [ -f "${weight_file}" ] && rm -f "${weight_file}"
    [ -f "${grid_file}" ] && rm -f "${grid_file}"
  fi

  # Remove the sst NetCDF file
  #[ -f "${out_file}" ] && rm -f ${out_file}
  ########################

  return 0
}
############################################################


############################################################
##### IDL RELATED FUNCTIONS
############################################################
# -------------------------------------------------------
# ModifyIDLVar()
# Usage:      ModifyIDLVar file_name var_name var_value
# Parameters: file_name var_name var_value
#             file_name: the filename to use
#             var_name : the name of the variable to modify
#             var_value: the new value of the variable

# Returns:    NONE
# Exports:    NONE
# Echoes:     NONE
#
# Modifies the value of a variable in the input idl file.
# -------------------------------------------------------
ModifyIDLVar()
{
  local nm_func="${FUNCNAME[0]}"

  local fname vname vvalue
  local my_val chk_val
  local xpr1 xpr2

  if [ $# -lt 3 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} FileName VarName VarValue"
  fi

  if [ ! -f "${1}" ]; then
    procError "need to define a valid filename" \
              "usage: ${nm_func} fname vname vvalue"
  fi

  fname="${1}"
  vname="$( strESC "$( echo "${2}" | sed 's/[[:space:]]//g' )" )"
  vvalue="$( strESC "${3}" )"

  chk_val="$( echo "${vvalue}" | grep -i '!VALUES.' )"

  my_val="${vvalue}"
  if ! $( isNumber "${my_val}" ) && [ -z "${chk_val:-}" ] ; then
    my_val="\'${my_val}\'"
  fi
  
  xpr1="^[[:space:]]*${vname}[[:space:]]*=[[:space:]]*"
  xpr2="${my_val}"
  sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${fname}
}

# -------------------------------------------------------
# Modify_IDLVars()
# Usage:      Modify_IDLVars file_name var_name var_value
# Returns:    NONE
# Echoes:     NONE
#
# Sets (if found) "var_name" to "var_value" in the file "file_name"
# using "sed" expressions.
# -------------------------------------------------------
Modify_IDLVars()
{
  local nm_func="${FUNCNAME[0]}"

  local file var_name var_val
  local xpr1 xpr2
  local -i isSTRING=1

  if [ $# -lt 3 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} FileName VarName VarValue"
  fi

  file="${1}"
  var_name="$( toUPPER "$( echo "${2}" | sed 's/[[:space:]]//g' )" )"
  var_name="$( strESC "${var_name}" )"

  var_val="${3}"
  var_val="$( strESC "${var_val}" )"

  if isNumber "${var_val}"; then isSTRING=0; fi

  case "${var_name}" in
    HYC_ROOTDIR)
        xpr1='^[[:space:]]*hyc_rootDIR[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    HYC_DATADIR)
        xpr1='^[[:space:]]*hyc_dataDIR[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    HYC_OUTDIR)
        xpr1='^[[:space:]]*hyc_outDIR[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    INIT_DATE)
        xpr1='^[[:space:]]*INIT_DATE[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    BEG_DATE)
        xpr1='^[[:space:]]*BEG_DATE[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    END_DATE)
        xpr1='^[[:space:]]*END_DATE[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    DOM_NUMB)
        xpr1='^[[:space:]]*DOM_NUMB[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    USE_GPAR)
        xpr1='^[[:space:]]*USE_GPAR[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    CONV_PLOTS)
        xpr1='^[[:space:]]*CONV_PLOTS[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    CONV_PROG)
        xpr1='^[[:space:]]*CONV_PROG[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    CONV_GEOM1)
        xpr1='^[[:space:]]*CONV_GEOM1[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    CONV_GEOM2)
        xpr1='^[[:space:]]*CONV_GEOM2[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    PARA_PROG)
        xpr1='^[[:space:]]*PARA_PROG[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    IMG_TYPE)
        xpr1='^[[:space:]]*IMG_TYPE[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    INP_DIR)
        xpr1='^[[:space:]]*INP_DIR[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    OUT_DIR)
        xpr1='^[[:space:]]*OUT_DIR[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    PLOT_VARS)
        xpr1='^[[:space:]]*PLOT_VARS[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    CAST_ROOT)
        xpr1='^[[:space:]]*CAST_ROOT[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    CAST_BATH)
        xpr1='^[[:space:]]*CAST_BATH[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    CAST_PLOTS)
        xpr1='^[[:space:]]*CAST_PLOTS[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    CAST_OUT)
        xpr1='^[[:space:]]*CAST_OUT[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    FCYCLE)
        xpr1='^[[:space:]]*FCYCLE[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    HC_IDXI0)
        xpr1='^[[:space:]]*HC_IDXI0[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    HC_IDXI1)
        xpr1='^[[:space:]]*HC_IDXI1[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    HC_IDXJ0)
        xpr1='^[[:space:]]*HC_IDXJ0[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    HC_IDXJ1)
        xpr1='^[[:space:]]*HC_IDXJ1[[:space:]]*='
        if [ ${isSTRING} -gt 0 ]; then
          xpr2=" \'${var_val}\'"
        else
          xpr2=" ${var_val}"
        fi
      sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${file}
    ;;
    *)
      procError "unsupported variable name" \
                "VarName  = ${2}" \
                "VarValue = ${3}"
    ;;
  esac
}
############################################################


############################################################
##### WRF/WPS RELATED FUNCTIONS
############################################################
# -------------------------------------------------------
# getNameListVar()
# Usage:      getNameListVar file_name var_name [ndoms]
# Parameters: file_name var_name
#             file_name  : the filename to use
#             var_name   : the name of the variable to check
#             ndoms      : the number of domains (optional)
# Returns:    1 if there is an error (failure)
#             0 in any other case (success)
# Exports:    NONE
# Echoes:     a string that contains the fields:
#             var_name numb_of_var_values var_values (up to numb_of_var_values)
#             upon failure the string will contain the error message
#
# Checks for a variable in the input namelist file and returns
# the string that contains the variable information
# -------------------------------------------------------
getNameListVar()
{
  local nm_func="${FUNCNAME[0]}"

  local fname vname ndoms
  local chkVAR chkVAL tmpVAL
  local ival nVAL varNAM varVAL

  unset VAR_STRING VAR_VALUE

  if [ $# -lt 2 ]; then
    procError "need to define the filename and the variable to examine" \
              "usage: ${nm_func} fname vname"
  fi

  if [ ! -f "${1}" ]; then
    procError "need to define a valid filename" \
              "usage: ${nm_func} fname vname"
  fi

  fname="${1}"
  vname="${2}"
  ndoms="$( getPosInteger "${3}" )"

  chkVAR="$(grep -Ei "^[[:space:]]*${vname}[[:space:]]*=" ${fname} 2>/dev/null)"

  if [ -z "${chkVAR:-}" ]; then
    echo
    return 1
  fi

  varNAM=$( echo "${chkVAR}" | sed -e 's/=.*//g' | \
            awk '{print $1}' )

  chkVAL=( $( echo "${chkVAR}" | sed -e 's/.*=//g'| \
             sed -e 's/[=;,]/ /g' ) )

  nVAL=${#chkVAL[@]}
  if [ -n "${ndoms:+1}" ]; then
    [ ${ndoms} -le 0 ] && ndoms=1
    nVAL="$( min "${nVAL} ${ndoms}" )"
  fi

  for (( ival = 0; ival < ${nVAL}; ival++ ))
  do
    tmpVAL="$( echo "${chkVAL[${ival}]}" | sed -e "s/[\"\']//g" )"
    if [ -z "${varVAL:-}" ]; then
      varVAL="${tmpVAL}"
    else
      varVAL="${varVAL} ${tmpVAL}"
    fi
  done

  echo "${varNAM} ${nVAL} ${varVAL}"

  return 0
}

# -------------------------------------------------------
# ModifyNameListVar()
# Usage:      ModifyNameListVar file_name var_name var_value [num_domains]
# Parameters: file_name var_name var_value [num_domains]
#             file_name: the filename to use
#             var_name : the name of the variable to modify
#             var_value: the new value of the variable
#             num_domains: repeat the var_value[0] num_domains times
# NOTE:         If num_domains is defined and it is greater than zero,
#                 the final value string for the variable is constructed
#                 by repeating "num_domains" times the first "var_value"
#               In any other case the final value string for the variable
#                 is constructed using all elements in the "var_value"
#                 string
# Returns:    NONE
# Exports:    NONE
# Echoes:     NONE
#
# Modifies the value of a variable in the input namelist file.
# -------------------------------------------------------
ModifyNameListVar()
{
  local nm_func="${FUNCNAME[0]}"

  local fname vname vvalue ndom
  local ival my_val valSTR
  local xpr1 xpr2

  if [ $# -lt 3 ]; then
    procError "need to define the filename, the variable and its value to modify" \
              "usage: ${nm_func} fname vname vvalue [ndom]"
  fi

  if [ ! -f "${1}" ]; then
    procError "need to define a valid filename" \
              "usage: ${nm_func} fname vname vvalue [ndom]"
  fi

  fname="${1}"
  vname="$( strESC "$( echo "${2}" | sed 's/[[:space:]]//g' )" )"
  vvalue=( $( strESC "${3}" ) )

  ndom="$( getPosInteger "${4}" )"
  ndom=${ndom:-0}

  # If ndom is defined and it is greater than zero, then
  # construct the "value" string by repeating "ndom" times the
  # first vvalue (vvalue[0])
  if [ ${ndom} -gt 0 ]; then
    my_val="${vvalue[0]}"
    if ! $( isNumber "${my_val}" ) && ! $( isLogical "${my_val}" ) ; then
      my_val="\'${my_val}\'"
    fi

    for ((ival = 0; ival < ${ndom}; ival++))
    do
      if [ -z "${valSTR:-}" ]; then
        valSTR="${my_val},"
      else
        valSTR="${valSTR} ${my_val},"
      fi
    done
  # If ndom is undefined or it is less or equal to zero, then
  # construct the "value" string from the "vvalue" array
  else
    for ((ival = 0; ival < ${#vvalue[@]}; ival++))
    do
      my_val="${vvalue[${ival}]}"
      if ! $( isNumber "${my_val}" ) && ! $( isLogical "${my_val}" ) ; then
        my_val="\'${my_val}\'"
      fi

      if [ -z "${valSTR:-}" ]; then
        valSTR="${my_val},"
      else
        valSTR="${valSTR} ${my_val},"
      fi
    done
  fi
  
  xpr1="^[[:space:]]*${vname}[[:space:]]*=[[:space:]]*"
  xpr2="${valSTR}"
  sed -i "s/\(${xpr1}\)\(.*\)/\1${xpr2}/gi" ${fname}
}
############################################################


############################################################
##### ROMS RELATED FUNCTIONS
############################################################
# -------------------------------------------------------
# Make_BlockText()
# Usage:      Make_BlockText inp_fname var_name var_vals var_vals_per_line
# Parameters:
#   inp_fname         : the input file to search for the
#                       variable "var_name", STRING
#   var_name          : the variable name to search for, STRING
#   var_vals          : the value(s) of the variable to be set,
#                       separated by spaces, STRING
#   var_vals_per_line : the number of values to be written in
#                       each line of the output, POSITIVE INTEGER
#   eqsigns           : the number of equal signs to be used for
#                       the variable, POSITIVE INTEGER
#                       var_name = var_vals, OR
#                       var_name == var_vals
# Returns:    1 if error
# Echoes :    the multi-line string that contains the block text
#             that defines the variable to be set
#
# Make_BlockText creates the block text to be used in 
# function "Put_BlockText".
# -------------------------------------------------------
Make_BlockText()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0 ival imod vals_perline eqsigns
  local inp_file
  local in_var in_vals eq_var
  local bl_var bl_var_blank
  local tmp_file=tmp_block_text_file.tmp

  if [ $# -lt 3 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename varname varvalues [values per line]"
  fi

  inp_file="${1}"
  in_var="${2}"
  in_vals=( ${3} )
  vals_perline=$(( ${4:-1} + 0 ))
    [ ${vals_perline} -le 0 ] && vals_perline=1
  eqsigns=$(( ${5:-2} + 0 ))
    [ ${eqsigns} -le 1 ] && eq_var="="
    [ ${eqsigns} -ge 2 ] && eq_var="=="

  retval=$?

  if ! $( checkFILE -r "${inp_file}" ); then
    procError "could not locate the input file:" \
              "file = ${inp_file}"
  fi

  bl_var="$( echo "${in_var}" | sed -e 's/[()]/\\\&/g' )"
  bl_var="$( grep -Ei -m 1 "^[[:space:]]*${bl_var}[[:space:]]*=" "${inp_file}" 2>&1 )"
  bl_var="$( echo "${bl_var}" | sed -e 's/\!.*//g' | sed -e "s/\(.*${in_var}\).*/\1/" )"
  bl_var="$( echo "${bl_var}" ) ${eq_var}"
  bl_var_blank="$( echo "${bl_var}" | sed -e 's/./ /g' )"
  retval=$?

  [ -f ${tmp_file} ] && rm -f ${tmp_file}

  for ((ival = 0; ival < ${#in_vals[@]}; ival++))
  do
    imod=$(( ${ival} % ${vals_perline} ))
    if [ ${ival} -ne 0 -a ${imod} -eq 0 ]; then
      echo -n " \\"              >> ${tmp_file}
      echo                       >> ${tmp_file}
      echo -n "${bl_var_blank}"  >> ${tmp_file}
    fi
    if [ ${ival} -eq 0 ]; then
      echo -n "${bl_var}"        >> ${tmp_file}
    fi
    echo -n " ${in_vals[$ival]}" >> ${tmp_file}
    if [ ${ival} -eq $(( ${#in_vals[@]} - 1 )) ]; then
      echo                       >> ${tmp_file}
    fi
  done

  echo -n "$( cat ${tmp_file} )"
  retval=$?

  [ -f ${tmp_file} ] && rm -f ${tmp_file}

  return ${retval}
}

# -------------------------------------------------------
# Get_BlockText()
# Usage:      Get_BlockText inp_fname var_name
# Parameters:
#   inp_fname         : the input file to search for the
#                       variable "var_name", STRING
#   var_name          : the variable name to search for, STRING
# Returns:    1 if error
#
# Get_BlockText exports the multi-line text starting
# the first line that contains the string "var_name"
# and ending at a blank line or at the line that does not
# contain the continuation character "\".
# The following global variables are set:
#   bl_first      : contains the first line of the block text
#   bl_first_nline: contains the line number in the input file
#                   of the first line of the block text
#   bl_text       : contains the text of consecutive lines
#                   in the block
#   bl_nlines     : contains the total number of lines
#                   in the block text
# -------------------------------------------------------
Get_BlockText()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0
  local inp_file= in_var=

  unset bl_first bl_text bl_first_nline bl_nlines

  if [ $# -lt 2 ]; then
    bl_text=""
    bl_first=""
    bl_first_nline=-1
    bl_nlines=-1
    export bl_first bl_text bl_first_nline bl_nlines
    return 1
  fi

  inp_file="${1}"
  in_var="^[[:space:]]*$( echo "${2}" | sed -e 's/[()]/\\\&/g' )[[:space:]]*="

  if ! $( checkFILE -r "${inp_file}" ); then
    procError "could not locate the input file: ${inp_file}"
  fi

  bl_first="$( grep -Ei "${in_var}" "${inp_file}" )"
  bl_first_nline="$( grep -nEi "${in_var}" "${inp_file}" )"
  bl_first_nline="$( echo "${bl_first_nline}" | sed 's/:/ /g' | awk '{print $1}' )"
  bl_first_nline=$(( ${bl_first_nline} + 0 ))

  bl_nlines=0
  if [ -n "${bl_first:+1}" ]; then
    bl_text="cat ${inp_file} | awk 'BEGIN{IGNORECASE=1} /${in_var}/,/^$/ || /^[^\\\]*$/'"
    bl_text="$( eval ${bl_text} )"
    bl_nlines="$( echo "${bl_text}" | wc -l )"
  fi

  export bl_first bl_text bl_first_nline bl_nlines

  return ${retval}
}

# -------------------------------------------------------
# Put_BlockText()
# Usage:      Put_BlockText inp_fname var_name rep_text
# Parameters:
#   inp_fname         : the input file to search for the
#                       variable "var_name", STRING
#   var_name          : the variable name to search for, STRING
#   rep_text          : the text to replace the "var_name" text
#                       in "inp_fname", STRING

# Returns:    1 if error
#
# Put_BlockText creates the modified input file, where
# the block text that defines the variable "var_name"
# is replaced by the block text in "rep_text".
# -------------------------------------------------------
Put_BlockText()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0 inp_file_lines=0 nl=0
  local in_var rep_text inp_file
  local tmp_inp_txtfile="tmp_inp_text_file.tmp"
  local tmp_rep_txtfile="tmp_rep_text_file.tmp"
  local tmp_inp_file="tmp_inp_file.tmp"
  local tmp_head_file="tmp_head_file.tmp"
  local tmp_tail_file="tmp_tail_file.tmp"

  if [ $# -lt 3 ]; then
    procError "wrong number of arguments" \
              "usage: ${nm_func} filename search_string replacement_text"
  fi

  inp_file="${1}"
  in_var="${2}"
  rep_text="${3}"

  if ! $( checkFILE -r "${inp_file}" ); then
    procError "could not locate the input file: ${inp_file}"
  fi

  Get_BlockText "${inp_file}" "${in_var}"
  retval="$?"

  if [ "${bl_first_nline}" -le 0 -o "${bl_nlines}" -le 0 ]; then
    unset bl_first bl_text bl_first_nline bl_nlines
    return 1
  fi

  inp_file_lines=$( cat "${inp_file}" | wc -l )
  if [ "${inp_file_lines}" -lt "${bl_nlines}" ]; then
    unset bl_first bl_text bl_first_nline bl_nlines
    return 1
  fi

  echo "${bl_text}"  > ${tmp_inp_txtfile}

  echo "${rep_text}" > ${tmp_rep_txtfile}

    nl=$(( ${bl_first_nline} - 1 ))
  head -n ${nl} "${inp_file}" > ${tmp_head_file}
  retval="$?"

    nl=$(( ${inp_file_lines} - ${bl_first_nline} - ${bl_nlines} + 1 ))
  tail -n ${nl} "${inp_file}" > ${tmp_tail_file}
  retval="$?"

  cat ${tmp_head_file} ${tmp_rep_txtfile} ${tmp_tail_file} > ${tmp_inp_file}
  retval="$?"

  rm -f ${tmp_inp_txtfile} ${tmp_rep_txtfile}
  rm -f ${tmp_head_file} ${tmp_tail_file}
  unset bl_first bl_text bl_first_nline bl_nlines

  if [ ${retval} -eq 0 ]; then
    rm -f "${inp_file}"
    mv -f "${tmp_inp_file}" "${inp_file}"
  fi

  return ${retval}
}
############################################################


############################################################
##### HYCOM RELATED FUNCTIONS
############################################################
# -------------------------------------------------------
# hyc_getModDataFile()
# Usage:      hyc_getModDataFile f{name/expr} search_dirs
# Parameters: fname or fexpr, search_dirs, BegDate
#             fname: the filename to search for (mandatory) OR
#             fexpr: the list of filename regular expressions
#                    to search for (mandatory)
#             search_dirs: the list of directories to search
#                          for the above files (mandatory)
# Returns:    0 if a valid file found (success)
#             1 in any other case (error)
# Exports:    foundFilePath
# Echoes:     NONE
#
# Find the file that meets the user's criteria.
# -------------------------------------------------------
hyc_getModDataFile()
{
  local nargs
  local fexpr fdirs
  local fileA fileB
  local -i retval=1

  nargs=$#
  fexpr="${1}"
  fdirs="${2}"

  case 1 in
    $(( ${nargs} >= 2 )) )
      getModDataFile "$fexpr}*.a" "${fdirs}"
      fileA="${foundFilePath}"

      getModDataFile "$fexpr}*.b" "${fdirs}"
      fileB="${foundFilePath}"

      retval=0
    ;;
    *)
      procError "wrong number of arguments" \
                "usage: ${nm_func} \"fname_expr\" \"dirs_to_search\""
    ;;
  esac

  export foundFilePath="${fileA} ${fileB}"

  return ${retval}
}

# -------------------------------------------------------
# hyc_GetBlkDatLine()
# Usage:      hyc_GetBlkDatLine inp_file var_name [var_def]
# Parameters:
# inp_file : The name of the HYCOM input configuration file.
#            The input file to search for the variable "var_name"
#            (STRING).
# var_name : The variable name to search for (STRING).
#  var_def : An optional variable definition sub-string to help
#            in the search (STRING).
#
# Returns : 0 (success), 1 (failure)
#           1 = empty line (variable not found, or a general error)
#
# hyc_GetBlkDatLine: Returns the line in the blkdat.input HYCOM file
#                    that contains the value and the name of the
#                    supplied "var_name".
# -------------------------------------------------------
hyc_GetBlkDatLine()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=1
  local inp_file inp_var inp_def
  local line
  local xpr1 xpr2

  if [ $# -lt 2 ]; then
    echo -n "${line}"
    return ${retval}
  fi

  inp_file="${1}"
  inp_var="$( echo "${2}" | sed -e 's/[()]/\\\&/g' )"
  inp_def="${3}"

  # In the HYCOM "blkdat.input" file, each line contains the following fields:
  # Field 1: value of the variable (always arithmetic? scientific or normal number)
  # Field 2: name of the variable (string)
  # Field 3: explanation of the variable (after the = sign)
  # We use Field2 (and possibly Field3) to get the line from the input file.
  xpr1="[\'\"][[:space:]]*${inp_var}[[:space:]]*[\'\"][[:space:]]*="
  xpr2=".*${inp_def:+${inp_def}.*}$"

  if $( checkFILE -r "${inp_file}" ); then
    line="$( grep -Ei "${xpr1}${xpr2}" ${inp_file} 2>/dev/null | \
             sed -e 's/\!.*//g' )"

    [ -n "${line:+1}" ] && retval=0
  fi

  echo -n "${line}"

  return ${retval}
}

# -------------------------------------------------------
# hyc_PutBlkDatLine()
# Usage:      hyc_PutBlkDatLine inp_file var_line var_value [var_form]
# Parameters:
#  inp_file : The name of the HYCOM input configuration file.
#             The input file to search for the variable "var_name"
#             (STRING).
#  var_line : The file line that contains the variable name/value
#             pair (STRING). "var_line" is obtained by a previous
#             call to hyc_GetBlkDatLine.
# var_value : The variable value to replace.
#  var_form : The format to use for the variable value (C-style, optional).
#
# Returns : 0 (success), 1 (failure)
#           1 = empty line (variable not found)
#
# hyc_PutBlkDatLine: Replaces the value of the variable in the supplied line
#                    of the blkdat.input HYCOM file.
# -------------------------------------------------------
hyc_PutBlkDatLine()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=1
  local inp_file inp_line inp_val inp_form
  local var_name var_val part1 part2
  local len1 len2

  local xpr1 xpr2 xpr3

  [ $# -lt 3 ] && return ${retval}

  inp_file="${1}"
  inp_line="${2}"
  inp_val="${3}"


  # Ouput format of "var_val"
  inp_form="${4}"
  if [ -z "${inp_form:-}" ]; then
    if $( isInteger "${inp_val}" ); then
      inp_form="%4d      " 
    elif $( isNumber "${inp_val}" ); then
      inp_form="%6.1f    "
    else
      inp_form="%.10s"
    fi
  fi
  # Add a trailing space in inp_form if it does not have it
  len1=${#inp_form}
    len2=$(echo "${inp_form}" | sed 's/[[:space:]]*$//')
  len2=${#len2}
  [ ${len1} -eq ${len2} ] && inp_form="${inp_form} "

  if $( checkFILE -r "${inp_file}" ); then
    # Get the old value/name pair from the input file
    # In sed: \x27 = ' (not working with grep)
    # In sed: \x22 = " (not working with grep)
    var_val="$( echo "${inp_line}" | awk '{print $1}' )"
    var_name="$( echo "${inp_line}" | awk '{print $2}' | \
                 sed 's/[\x27\x22[:space:]]//g' )"

    # Split the line in two parts
    part1="$( echo "${inp_val}" | \
              awk -v f="${inp_form}" 'BEGIN {fmt=f} {printf fmt,  $1}' )"
    part1="$( echo "${part1}" | \
              sed 's/^\([[:space:]]*\)0\.\(.*\)/\1\.\2/g' )"
    part2="$( echo "${inp_line}" | sed "s/${var_val}//" | \
              sed 's/^[[:space:]]*//g' )"

    # Replace the line
    inp_line="$( strESC1 "${inp_line}" )"
    part1="$( strESC1 "${part1}" )"
    part2="$( strESC1 "${part2}" )"

    sed -i -e "s/${inp_line}/${part1}${part2}/gi" ${inp_file}
    retval=$?
  fi

  return ${retval}
}

# -------------------------------------------------------
# hyc_GetBlkDatValue()
# Usage:      hyc_GetBlkDatValue inp_file inp_var inp_def
# Parameters:
#  inp_file : The name of the HYCOM input configuration file.
#             The input file to search for the variable "var_name"
#             (STRING).
#   inp_var : The ariable name (STRING).
#   inp_def : An optional variable definition sub-string to help
#             in the search (STRING).
#
# Returns : 0 (success), 1 (failure)
#           1 = empty value (variable not found)
#
# hyc_GetBlkDatValue: Obtains the value of the variable from the
#                     supplied blkdat.input HYCOM file.
# -------------------------------------------------------
hyc_GetBlkDatValue()
{
  local nm_func="${FUNCNAME[0]}"

  local -i retval=0
  local inp_file inp_var inp_def inp_val


  ### Check for the number of arguments
  if [ $# -lt 2 ]; then
    inp_val="Need to define the filename and the variable name
          usage: ${nm_func} fname vname [vdef]"
    echo -n "${inp_val}"
    return 1
  fi

  ### Check for the input file
  if ! $( checkFILE -r "${1}" ); then
    inp_val="Could not find the HYCOM input file:
          File = ${1:-UNDEF}"
    echo -n "${inp_val}"
    return 1
  fi


  inp_file="${1}"
  inp_var="$( toLOWER "$( echo "${2}" | sed -e 's/[()]/\\\&/g' )" )"
  inp_def="${3:-}"


  case ${inp_var} in
    iversn )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    iexpt )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    idm )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -eq 0 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (> 0)"
        return 1
      fi
    ;;
    jdm )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -eq 0 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (> 0)"
        return 1
      fi
    ;;
    kdm )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -eq 0 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (> 0)"
        return 1
      fi
    ;;
    nhybrd )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    nsigma )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    yrflag )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 3 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-3)"
        return 1
      fi
    ;;
    dsurfq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    diagfq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    proffq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    tilefq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    meanfq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    rstrfq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    bnstfq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    nestfq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    cplifq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    frzifq )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    baclin )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    batrop )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    jerlv0 )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 5 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-5)"
        return 1
      fi
    ;;
    priver )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -ne 0 -a ${inp_val} -ne 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-1)"
        return 1
      fi
    ;;
    isotop )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    saln0 )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    thbase )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    vsigma )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -ne 0 -a ${inp_val} -ne 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-1)"
        return 1
      fi
    ;;
    veldf2 )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    veldf4 )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    thkdf2 )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    thkdf4 )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    wndflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 4 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-4)"
        return 1
      fi
    ;;
    stroff )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -ne 0 -a ${inp_val} -ne 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-1)"
        return 1
      fi
    ;;
    flxflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 4 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-4)"
        return 1
      fi
    ;;
    ustflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -lt 1 -o ${inp_val} -gt 4 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (1-4)"
        return 1
      fi
    ;;
    empflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 4 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-4)"
        return 1
      fi
    ;;
    lwflag )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 2 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-2)"
        return 1
      fi
    ;;
    sstflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 3 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-3)"
        return 1
      fi
    ;;
    icmflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 3 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-3)"
        return 1
      fi
    ;;
    ticegr )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    flxoff )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -ne 0 -a ${inp_val} -ne 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-1)"
        return 1
      fi
    ;;
    fltflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -ne 0 -a ${inp_val} -ne 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-1)"
        return 1
      fi
    ;;
    tidflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 3 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-3)"
        return 1
      fi
    ;;
    drgscl )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    tidsal )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( echo "${inp_line}" | awk '{print $1}' 2>/dev/null )"
      isNumber "${inp_val}"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    iniflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -gt 3 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-3)"
        return 1
      fi
    ;;
    sshflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -ne 0 -a ${inp_val} -ne 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-1)"
        return 1
      fi
    ;;
    sssflg )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -lt -1 -o ${inp_val} -gt 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (-1 -- 1)"
        return 1
      fi
    ;;
    relax )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -ne 0 -a ${inp_val} -ne 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-1)"
        return 1
      fi
    ;;
    trcrlx )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getPosInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      elif [ ${inp_val} -ne 0 -a ${inp_val} -ne 1 ]; then
        inp_val="Wrong value for \"${inp_var}\" found in:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val} (0-1)"
        return 1
      fi
    ;;
    ntracr )
      inp_line="$( hyc_GetBlkDatLine ${inp_file} ${inp_var} "${inp_def}" )"
      inp_val="$( getInteger "$( echo "${inp_line}" | \
                  awk '{print $1}' 2>/dev/null )" )"
      if [ $? -ne 0 ]; then
        inp_val="Could not determine the value for \"${inp_var}\" from:
          ${inp_line}
          ${inp_var} = ${inp_val:-UNDEF}"
        echo -n "${inp_val}"
        return 1
      fi
    ;;
    *)
      inp_val="Unsupported variable supplied: ${inp_var}"
      echo -n "${inp_val}"
      return 1
    ;;
  esac


  echo -n "${inp_val}"

  return ${retval}
}

# -------------------------------------------------------
# hyc_Archv2DNcdf()
# Usage:      hyc_Archv2DNcdf --conf=conf_file [optional, default: blkdat.input]
#                             --inp=inp_file [mandatory, archv*.a]
#                             --prog=exe_prog [default: archv2ncdf2d]
# Parameters:
# conf_file : The name of the HYCOM input configuration file.
#             The input file to search for HYCOM variables
#             (STRING).
#  inp_file : The name of the HYCOM input archv*.a file.
#             (STRING).
#  exe_prog : The name of the archv2ncdf program (STRING).
#
# Returns : 0 (success), 1 (failure)
# Exports : NCDFarchFILES (the list of the created NetCDF files)
# Echoes  : NONE
#
# hyc_Archv2DNcdf: Creates a NetCDF file from an archv HYCOM file,
#                  the NetCDF file contains 2d fields only.
# -------------------------------------------------------
hyc_Archv2DNcdf()
{
  local nm_func=${FUNCNAME[0]}

  local nm_ext=2d nm_prog="archv2ncdf2d"
  local my_prog exe_prog

  local conf_file inp_file
  local f_inp f_out
  local f_err f_log

  local iexpt idm jdm kdm yrflag ntracr thbase

  local    ilst jlst klst
  local -i icnt=0 jcnt=0 kcnt=0

  local def_lun=51 lun flun
  
  local opt_all opt_opt opt_arg
  local -i STATUS=0

  local cwd="$( pwd )"


  lun=${def_lun}
  unset NCDFarchFILES


  # -----
  # Process the function options
  opt_all=( conf inp lun prog )
  opt_all=":$( echo "${opt_all[@]/#/-} ${opt_all[@]/#/--}" | sed 's/ /:/g' ):"

  __OPTION_LIST=
  while test $# -gt 0; do
    case "${1}" in
      -[^-]*=* | --[^-]*=* )
        opt_opt="$( toLOWER "$( echo "${1}" | sed 's/=.*//' )" )"
        opt_arg="$( strTrim "$( echo "${1}" | sed 's/.*=//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      -[^-]* | --[^-]* )
        opt_opt="$( toLOWER "${1}" )"
        opt_arg="$( strTrim "$( echo "${2}" | sed 's/=.*//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      *)
        opt_opt= 
        opt_arg=
        ;;
    esac

    case "${opt_opt}" in
      -conf | --conf )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              conf_file="${opt_arg}"
          fi
        ;;
      -inp | --inp )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              inp_file="${opt_arg}"
          fi
        ;;
      -lun | --lun )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              lun="$( getPosInteger "${opt_arg}" )"
              lun=${lun:-${def_lun}}
          fi
        ;;
      -prog | --prog )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              my_prog="${opt_arg}"
          fi
        ;;
      *) ;; # DEFAULT
    esac
    shift
    opt_opt= 
    opt_arg=
  done
  __OPTION_LIST=
  # -----


  # -----
  # Check for the user inputs and the required programs.
  ### Check for the required program
  exe_prog="$( getPROG ${my_prog:-${nm_prog}} )"
  if [ $? -ne 0 ]; then
    procWarn "${exe_prog}"
    return 1
  fi

  if [ ${lun} -lt 1 -o ${lun} -gt 999 ]; then
    procError "The Logical Unit Number (LUN) should be between 1 and 999"
  fi

  flun="$( get3DString ${lun} )"
  unset CDF${flun}
  # -----


  # -----
  # Get all the required data and variables necessary for
  # subsequent calculations.
  ### Read the input configuration file and get the following variables
  conf_file="${conf_file:-blkdat.input}"
  if ! $( checkFILE -r "${conf_file}" ); then
    iexpt=000
    yrflag=3
    ntracr=0
    idm=541
    jdm=385
    kdm=27
    thbase=25.0
  else
    iexpt="$( hyc_GetBlkDatValue ${conf_file} iexpt "" )"
      [ $? -ne 0 ] && procError "${iexpt}"
    yrflag="$( hyc_GetBlkDatValue ${conf_file} yrflag "" )"
      [ $? -ne 0 ] && procError "${yrflag}"
    ntracr="$( hyc_GetBlkDatValue ${conf_file} ntracr "" )"
      [ $? -ne 0 ] && procError "${ntracr}"
    idm="$( hyc_GetBlkDatValue ${conf_file} idm "" )"
      [ $? -ne 0 ] && procError "${idm}"
    jdm="$( hyc_GetBlkDatValue ${conf_file} jdm "" )"
      [ $? -ne 0 ] && procError "${jdm}"
    kdm="$( hyc_GetBlkDatValue ${conf_file} kdm "" )"
      [ $? -ne 0 ] && procError "${kdm}"
    thbase="$( hyc_GetBlkDatValue ${conf_file} thbase "" )"
      [ $? -ne 0 ] && procError "${thbase}"
  fi
  # -----


  # -----
  # Create the NetCDF file(s).
  for ilst in ${inp_file}
  do
    if $( checkFILE -r "${ilst}" ); then
      f_inp=${ilst}
      f_out=${f_inp%.*}${nm_ext:+_${nm_ext}}.nc
      f_log=${nm_func}_$( basename ${f_out%.*} ).log

      export CDF_TITLE="GoM Forecasting System"
      export CDF_INST="$( cat << EOF

Center for Ocean-Atmospheric Prediction Studies (COAPS)
Florida State University
2000 Levy Avenue, Building A, Suite 292
Tallahassee, FL 32306-2741
URL: http://www.coaps.fsu.edu
EOF
)"
      export CDF${flun}=${f_out}
      [ -f "${f_out}" ] && rm -f ${f_out}
      [ -f "${f_log}" ] && rm -f ${f_log}

${exe_prog} << EOF > ${f_log} 2>&1
${f_inp}
netCDF
 ${iexpt} 'iexpt ' = experiment number x10 (000=from archive file)
 ${yrflag} 'yrflag' = days in year flag (0=360J16,1=366J16,2=366J01,3-actual)
 ${idm} 'idm   ' = longitudinal array size
 ${jdm} 'jdm   ' = latitudinal  array size
 ${kdm} 'kdm   ' = number of layers
 ${thbase}	'thbase' = reference density (sigma units)
  0	'smooth' = smooth fields before plotting (0=F,1=T)
  0	'mthin ' = mask thin layers from plots   (0=F,1=T)
  1	'iorign' = i-origin of plotted subregion
  1	'jorign' = j-origin of plotted subregion
  0	'idmp  ' = i-extent of plotted subregion (<=idm; 0 implies idm)
  0	'jdmp  ' = j-extent of plotted subregion (<=jdm; 0 implies jdm)
 ${lun}	'botio ' = bathymetry       I/O unit (0 no I/O)
 ${lun}	'flxio ' = surf. heat flux  I/O unit (0 no I/O)
 ${lun}	'empio ' = surf. evap-pcip  I/O unit (0 no I/O)
 ${lun}	'ttrio ' = surf. temp trend I/O unit (0 no I/O)
 ${lun}	'strio ' = surf. saln trend I/O unit (0 no I/O)
  0	'icvio ' = ice coverage     I/O unit (0 no I/O)
  0	'ithio ' = ice thickness    I/O unit (0 no I/O)
  0	'ictio ' = ice temperature  I/O unit (0 no I/O)
 ${lun}	'sshio ' = sea surf. height I/O unit (0 no I/O)
 ${lun}	'buvio ' = baro. u-vel.     I/O unit (0 no I/O)
 ${lun}	'bvvio ' = baro. v-vel.     I/O unit (0 no I/O)
 ${lun}	'bspio ' = baro. speed      I/O unit (0 no I/O)
 ${lun}	'bsfio ' = baro. strmfn.    I/O unit (0 no I/O)
 ${lun}	'uvmio ' = mix. lay. u-vel. I/O unit (0 no I/O)
 ${lun}	'vvmio ' = mix. lay. v-vel. I/O unit (0 no I/O)
 ${lun}	'spmio ' = mix. lay. speed  I/O unit (0 no I/O)
 ${lun}	'bltio ' = bnd. lay. thick. I/O unit (0 no I/O)
 ${lun}	'mltio ' = mix. lay. thick. I/O unit (0 no I/O)
 ${lun}	'sstio ' = mix. lay. temp.  I/O unit (0 no I/O)
 ${lun}	'sssio ' = mix. lay. saln.  I/O unit (0 no I/O)
 ${lun}	'ssdio ' = mix. lay. dens.  I/O unit (0 no I/O)
  1	'kf    ' = first output layer (=0 end output; <0 label with layer #)
 ${kdm}	'kl    ' = last  output layer
  0	'uvlio ' = layer k   u-vel. I/O unit (0 no I/O)
  0	'vvlio ' = layer k   v-vel. I/O unit (0 no I/O)
  0	'splio ' = layer k   speed. I/O unit (0 no I/O)
  0	'wvlio ' = layer k   w-vel. I/O unit (0 no I/O)
  0	'infio ' = layer k   i.dep. I/O unit (0 no I/O)
  0	'thkio ' = layer k   thick. I/O unit (0 no I/O)
  0	'temio ' = layer k   temp   I/O unit (0 no I/O)
  0	'salio ' = layer k   saln.  I/O unit (0 no I/O)
  0 	'tthio ' = layer k   dens,  I/O unit (0 no I/O)
  0	'sfnio ' = layer k  strmfn. I/O unit (0 no I/O)
  0	'kf    ' = first output layer (=0 end output; <0 label with layer #)
EOF
      STATUS=$?
      if [ ${STATUS} -ne 0 ]; then
        procWarn "$( cat ${f_log} )" \
                 "  File: ${f_out}" \
                 "   Log: ${f_log}"
        [ -f ${f_out} ] && rm -f ${f_out}
        continue
      fi

      f_err="$( grep -Ei "error[[:space:]]*.*[-]?" ${f_log} )"
      if [ -n "${f_err:+1}" ]; then
        STATUS=$(( ${STATUS} + 1 ))
        procWarn "${f_err}" \
                 "  File: ${f_out}" \
                 "   Log: ${f_log}"
        [ -f "${f_out}" ] && rm -f ${f_out}
        continue
      fi

      [ -f "${f_log}" ] && rm -f ${f_log}
      NCDFarchFILES="${NCDFarchFILES} ${f_out}"
    fi
  done
  # -----

  unset CDF${flun}
  export NCDFarchFILES

  __OPTION_LIST=

  return ${STATUS}
}

# -------------------------------------------------------
# hyc_Archv3ZNcdf()
# Usage:      hyc_Archv3ZNcdf --conf=conf_file [optional, default: blkdat.input]
#                             --inp=inp_file [mandatory, archv*.a]
#                             --prog=exe_prog [default: archv2ncdf3z]
# Parameters:
# conf_file : The name of the HYCOM input configuration file.
#             The input file to search for HYCOM variables
#             (STRING).
#  inp_file : The name of the HYCOM input archv*.a file.
#             (STRING).
#  exe_prog : The name of the archv2ncdf program (STRING).
#
# Returns : 0 (success), 1 (failure)
# Exports : NCDFarchFILES (the list of the created NetCDF files)
# Echoes  : NONE
#
# hyc_Archv3ZNcdf: Creates a NetCDF file from an archv HYCOM file,
#                  the NetCDF file contains 3d fields only.
# -------------------------------------------------------
hyc_Archv3ZNcdf()
{
  local nm_func=${FUNCNAME[0]}

  local nm_ext=3z nm_prog="archv2ncdf3z"
  local my_prog exe_prog

  local conf_file inp_file
  local f_inp f_out
  local f_err f_log

  local iexpt idm jdm kdm yrflag ntracr thbase

  local    ilst jlst klst
  local -i icnt=0 jcnt=0 kcnt=0

  local def_lun=52 lun flun
  
  local opt_all opt_opt opt_arg
  local -i STATUS=0

  local cwd="$( pwd )"


  lun=${def_lun}
  unset NCDFarchFILES


  # -----
  # Process the function options
  opt_all=( conf inp lun prog )
  opt_all=":$( echo "${opt_all[@]/#/-} ${opt_all[@]/#/--}" | sed 's/ /:/g' ):"

  __OPTION_LIST=
  while test $# -gt 0; do
    case "${1}" in
      -[^-]*=* | --[^-]*=* )
        opt_opt="$( toLOWER "$( echo "${1}" | sed 's/=.*//' )" )"
        opt_arg="$( strTrim "$( echo "${1}" | sed 's/.*=//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      -[^-]* | --[^-]* )
        opt_opt="$( toLOWER "${1}" )"
        opt_arg="$( strTrim "$( echo "${2}" | sed 's/=.*//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      *)
        opt_opt= 
        opt_arg=
        ;;
    esac

    case "${opt_opt}" in
      -conf | --conf )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              conf_file="${opt_arg}"
          fi
        ;;
      -inp | --inp )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              inp_file="${opt_arg}"
          fi
        ;;
      -lun | --lun )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              lun="$( getPosInteger "${opt_arg}" )"
              lun=${lun:-${def_lun}}
          fi
        ;;
      -prog | --prog )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              my_prog="${opt_arg}"
          fi
        ;;
      *) ;; # DEFAULT
    esac
    shift
    opt_opt= 
    opt_arg=
  done
  __OPTION_LIST=
  # -----


  # -----
  # Check for the user inputs and the required programs.
  ### Check for the required program
  exe_prog="$( getPROG ${my_prog:-${nm_prog}} )"
  if [ $? -ne 0 ]; then
    procWarn "${exe_prog}"
    return 1
  fi

  if [ ${lun} -lt 1 -o ${lun} -gt 999 ]; then
    procError "The Logical Unit Number (LUN) should be between 1 and 999"
  fi

  flun="$( get3DString ${lun} )"
  unset CDF${flun}
  # -----


  # -----
  # Get all the required data and variables necessary for
  # subsequent calculations.
  ### Read the input configuration file and get the following variables
  conf_file="${conf_file:-blkdat.input}"
  if ! $( checkFILE -r "${conf_file}" ); then
    iexpt=000
    yrflag=3
    ntracr=0
    idm=541
    jdm=385
    kdm=27
    thbase=25.0
  else
    iexpt="$( hyc_GetBlkDatValue ${conf_file} iexpt "" )"
      [ $? -ne 0 ] && procError "${iexpt}"
    yrflag="$( hyc_GetBlkDatValue ${conf_file} yrflag "" )"
      [ $? -ne 0 ] && procError "${yrflag}"
    ntracr="$( hyc_GetBlkDatValue ${conf_file} ntracr "" )"
      [ $? -ne 0 ] && procError "${ntracr}"
    idm="$( hyc_GetBlkDatValue ${conf_file} idm "" )"
      [ $? -ne 0 ] && procError "${idm}"
    jdm="$( hyc_GetBlkDatValue ${conf_file} jdm "" )"
      [ $? -ne 0 ] && procError "${jdm}"
    kdm="$( hyc_GetBlkDatValue ${conf_file} kdm "" )"
      [ $? -ne 0 ] && procError "${kdm}"
    thbase="$( hyc_GetBlkDatValue ${conf_file} thbase "" )"
      [ $? -ne 0 ] && procError "${thbase}"
  fi
  # -----


  # -----
  # Create the NetCDF file(s).
  for ilst in ${inp_file}
  do
    if $( checkFILE -r "${ilst}" ); then
      f_inp=${ilst}
      f_out=${f_inp%.*}${nm_ext:+_${nm_ext}}.nc
      f_log=${nm_func}_$( basename ${f_out%.*} ).log

      export CDF_TITLE="GoM Forecasting System"
      export CDF_INST="$( cat << EOF

Center for Ocean-Atmospheric Prediction Studies (COAPS)
Florida State University
2000 Levy Avenue, Building A, Suite 292
Tallahassee, FL 32306-2741
URL: http://www.coaps.fsu.edu
EOF
)"
      export CDF${flun}=${f_out}
      [ -f "${f_out}" ] && rm -f ${f_out}
      [ -f "${f_log}" ] && rm -f ${f_log}

${exe_prog} << EOF > ${f_log} 2>&1
${f_inp}
netCDF
 ${iexpt} 'iexpt ' = experiment number x10 (000=from archive file)
 ${yrflag} 'yrflag' = days in year flag (0=360J16,1=366J16,2=366J01,3-actual)
 ${idm} 'idm   ' = longitudinal array size
 ${jdm} 'jdm   ' = latitudinal  array size
 ${kdm} 'kdm   ' = number of layers
 ${thbase}	'thbase' = reference density (sigma units)
  0	'smooth' = smooth fields before plotting (0=F,1=T)
  1	'iorign' = i-origin of plotted subregion
  1	'jorign' = j-origin of plotted subregion
  0	'idmp  ' = i-extent of plotted subregion (<=idm; 0 implies idm)
  0	'jdmp  ' = j-extent of plotted subregion (<=jdm; 0 implies jdm)
  1	'itype ' = interpolation type (0=sample,1=linear)
  53	'kz    ' = number of depths to sample
   0.0	'z     ' = sample depth  1
   2.0	'z     ' = sample depth  2
   4.0	'z     ' = sample depth  3
   6.0	'z     ' = sample depth  4
   8.0	'z     ' = sample depth  5
  10.0	'z     ' = sample depth  6
  15.0	'z     ' = sample depth  7
  20.0	'z     ' = sample depth  8
  25.0	'z     ' = sample depth  9
  30.0	'z     ' = sample depth 10
  35.0	'z     ' = sample depth 11
  40.0	'z     ' = sample depth 12
  45.0	'z     ' = sample depth 13
  50.0	'z     ' = sample depth 14
  55.0	'z     ' = sample depth 15
  60.0	'z     ' = sample depth 16
  65.0	'z     ' = sample depth 17
  70.0	'z     ' = sample depth 18
  75.0	'z     ' = sample depth 19
  80.0	'z     ' = sample depth 20
  85.0	'z     ' = sample depth 21
  90.0	'z     ' = sample depth 22
  95.0	'z     ' = sample depth 23
 100.0	'z     ' = sample depth 24
 150.0	'z     ' = sample depth 25
 200.0	'z     ' = sample depth 26
 250.0	'z     ' = sample depth 27
 300.0	'z     ' = sample depth 28
 350.0	'z     ' = sample depth 29
 400.0	'z     ' = sample depth 30
 450.0	'z     ' = sample depth 31
 500.0	'z     ' = sample depth 32
 550.0	'z     ' = sample depth 33
 600.0	'z     ' = sample depth 34
 650.0	'z     ' = sample depth 35
 700.0	'z     ' = sample depth 36
 750.0	'z     ' = sample depth 37
 800.0	'z     ' = sample depth 38
 850.0	'z     ' = sample depth 39
 900.0	'z     ' = sample depth 40
 950.0	'z     ' = sample depth 41
1000.0	'z     ' = sample depth 42
1500.0	'z     ' = sample depth 43
2000.0	'z     ' = sample depth 44
2500.0	'z     ' = sample depth 45
3000.0	'z     ' = sample depth 46
3500.0	'z     ' = sample depth 47
4000.0	'z     ' = sample depth 48
4500.0	'z     ' = sample depth 49
5000.0	'z     ' = sample depth 50
5500.0	'z     ' = sample depth 51
6000.0	'z     ' = sample depth 52
6500.0	'z     ' = sample depth 53
 ${lun}	'botio ' = bathymetry  I/O unit (0 no I/O)
 ${lun}	'mltio ' = mix.l.thk.  I/O unit (0 no I/O)
 ${lun}	'tempml' = temperature jump across mixed-layer (degC,  0 no I/O)
 ${lun}	'densml' = density jump across mixed-layer (kg/m3, 0 no I/O)
  0	'infio ' = intf. depth I/O unit (0 no I/O, <0 label with layer #)
 ${lun}	'wvlio ' = w-velocity  I/O unit (0 no I/O)
 ${lun}	'uvlio ' = u-velocity  I/O unit (0 no I/O)
 ${lun}	'vvlio ' = v-velocity  I/O unit (0 no I/O)
 ${lun}	'splio ' = speed       I/O unit (0 no I/O)
 ${lun}	'temio ' = temperature I/O unit (0 no I/O)
 ${lun}	'salio ' = salinity    I/O unit (0 no I/O)
 ${lun}	'tthio ' = density     I/O unit (0 no I/O)
EOF
      STATUS=$?
      if [ ${STATUS} -ne 0 ]; then
        procWarn "$( cat ${f_log} )" \
                 "  File: ${f_out}" \
                 "   Log: ${f_log}"
        [ -f ${f_out} ] && rm -f ${f_out}
        continue
      fi

      f_err="$( grep -Ei "error[[:space:]]*.*[-]?" ${f_log} )"
      if [ -n "${f_err:+1}" ]; then
        STATUS=$(( ${STATUS} + 1 ))
        procWarn "${f_err}" \
                 "  File: ${f_out}" \
                 "   Log: ${f_log}"
        [ -f "${f_out}" ] && rm -f ${f_out}
        continue
      fi

      [ -f "${f_log}" ] && rm -f ${f_log}
      NCDFarchFILES="${NCDFarchFILES} ${f_out}"
    fi
  done
  # -----

  unset CDF${flun}
  export NCDFarchFILES

  return ${STATUS}
}

# -------------------------------------------------------
# hyc_Archv2Ncdf3Z()
# Usage:      hyc_Archv2Ncdf3Z --conf=conf_file [optional, default: blkdat.input]
#                             --inp=inp_file [mandatory, archv*.a]
# Parameters:
# conf_file : The name of the HYCOM input configuration file.
#             The input file to search for HYCOM variables
#             (STRING).
#  inp_file : The name of the HYCOM input archv*.a file.
#             (STRING).
#
# Returns : 0 (success), 1 (failure)
# Exports : NONE
# Echoes  : NONE
#
# hyc_Archv2Ncdf3Z: Creates a NetCDF file from an archv HYCOM file,
#                   the NetCDF file contains 2d+3d fields. It uses
#                   hyc_Archv2DNcdf and hyc_Archv3ZNcdf to create
#                   the NetCDF file.
# -------------------------------------------------------
hyc_Archv2Ncdf3Z()
{
  local nm_func=${FUNCNAME[0]}

  local nm_ext=3z nm_prog="ncks"
  local exe_prog

  local conf_file inp_file
  local f_inp f_out
  local f_nam f_tmp
  local f_err f_log

  local f_ncdf2d f_ncdf3d
      
  local    ilst jlst klst
  local -i icnt=0 jcnt=0 kcnt=0

  local def_lun=51 lun flun

  local opt_all opt_opt opt_arg
  local -i STATUS=0 my_status

  local cwd="$( pwd )"


  lun=${def_lun}
  unset NCDFarchFILES


  # -----
  # Process the function options
  opt_all=( conf inp lun )
  opt_all=":$( echo "${opt_all[@]/#/-} ${opt_all[@]/#/--}" | sed 's/ /:/g' ):"

  __OPTION_LIST=
  while test $# -gt 0; do
    case "${1}" in
      -[^-]*=* | --[^-]*=* )
        opt_opt="$( toLOWER "$( echo "${1}" | sed 's/=.*//' )" )"
        opt_arg="$( strTrim "$( echo "${1}" | sed 's/.*=//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      -[^-]* | --[^-]* )
        opt_opt="$( toLOWER "${1}" )"
        opt_arg="$( strTrim "$( echo "${2}" | sed 's/=.*//' )" 2 )"
        [ "$( echo "${opt_all}" | egrep -o ":${opt_arg}:" )" ] && \
          opt_arg=
        ;;
      *)
        opt_opt= 
        opt_arg=
        ;;
    esac

    case "${opt_opt}" in
      -conf | --conf )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              conf_file="${opt_arg}"
          fi
        ;;
      -inp | --inp )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              inp_file="${opt_arg}"
          fi
        ;;
      -lun | --lun )
          checkFuncOpt "$( echo "${opt_opt}" | sed 's/^[-]*//' )"
          if [ "X${opt_arg}" != "X" ]; then
              lun="$( getPosInteger "${opt_arg}" )"
              lun=${lun:-${def_lun}}
          fi
        ;;
      *) ;; # DEFAULT
    esac
    shift
    opt_opt= 
    opt_arg=
  done
  __OPTION_LIST=
  # -----


  # -----
  # Check for the user inputs and the required programs.
  ### Check for the required program
  exe_prog="$( getPROG ${my_prog:-${nm_prog}} )"
  if [ $? -ne 0 ]; then
    procWarn "${exe_prog}"
    return 1
  fi

  if [ ${lun} -lt 1 -o ${lun} -gt 998 ]; then
    procError "The Logical Unit Number (LUN) should be between 1 and 999"
  fi
  # -----


  # -----
  # Create the NetCDF file(s).
  for ilst in ${inp_file}
  do
    if $( checkFILE -r "${ilst}" ); then
      unset f_ncdf2d f_ncdf3d
      STATUS=0
 
      f_inp=${ilst}
      f_nam=${f_inp%.*}

      f_out=${f_nam}${nm_ext:+_${nm_ext}}.nc
      f_log=${nm_func}_$( basename ${f_out%.*} ).log
      f_tmp=${f_nam}_tmp.nc

      [ -f "${f_out}" ] && rm -f ${f_out}
      [ -f "${f_log}" ] && rm -f ${f_log}
      [ -f "${f_tmp}" ] && rm -f ${f_tmp}

      ### Create the 2D HYCOM NetCDF file
      hyc_Archv2DNcdf --conf=${conf_file} --inp=${f_inp} --lun=${lun}
        my_status=$?
        STATUS=$(( ${STATUS} + ${my_status} ))
      [ ${my_status} -eq 0 ] && f_ncdf2d=${NCDFarchFILES}
      unset NCDFarchFILES

      ### Create the 3D HYCOM NetCDF file
      hyc_Archv3ZNcdf --conf=${conf_file} --inp=${f_inp} --lun=$(( ${lun} + 1 ))
        my_status=$?
        STATUS=$(( ${STATUS} + ${my_status} ))
      [ ${my_status} -eq 0 ] && f_ncdf3d=${NCDFarchFILES}
      unset NCDFarchFILES

      ### Combine the two HYCOM NetCDF files
      [ -f "${f_tmp}" ] && rm -f ${f_tmp}
      for jlst in ${f_ncdf2d} ${f_ncdf3d}
      do
        f_err="$( ${exe_prog} -a -h -A ${jlst} ${f_tmp} 2>&1 )"
          my_status=$?
          STATUS=$(( ${STATUS} + ${my_status} ))
        if [ ${my_status} -ne 0 ]; then
          rm -f ${f_tmp}
          procWarn "${f_err}"
          break
        fi
      done

      ### Delete the individual 2D/3D HYCOM NetCDF files
      #   and rename the resulting one
      if [ -f "${f_tmp}" ]; then
        rm -f ${f_ncdf2d} ${f_ncdf3d}
        mv -f ${f_tmp} ${f_out}
      fi
    fi
  done
  # -----

  return ${STATUS}
}
############################################################
